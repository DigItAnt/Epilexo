(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('@angular/core'),require('@angular/common'),require('@angular/cdk/overlay'),exports, require('@angular/cdk/overlay'), require('@angular/common'), require('@angular/core'), require('@angular/cdk/portal'), require('rxjs'), require('@angular/cdk/a11y'), require('rxjs/operators')) :
  typeof define === 'function' && define.amd ? define('ngx-contextmenu', ['@angular/core','@angular/common','@angular/cdk/overlay','exports', '@angular/cdk/overlay', '@angular/common', '@angular/core', '@angular/cdk/portal', 'rxjs', '@angular/cdk/a11y', 'rxjs/operators'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.ng.core,global.ng.common,global.ng.cdk.overlay,global['ngx-contextmenu'] = {}, global.ng.cdk.overlay, global.ng.common, global.ng.core, global.ng.cdk.portal, global.rxjs, global.ng.cdk.a11y, global.rxjs.operators));
}(this, (function (ɵngcc0,ɵngcc1,ɵngcc2,exports, overlay, common, core, portal, rxjs, a11y, operators) { 
var _c0 = ["menu"];
var _c1 = ["li"];
function ContextMenuContentComponent_li_3_a_2_ng_template_1_Template(rf, ctx) { }
var _c2 = function (a0) { return { $implicit: a0 }; };
function ContextMenuContentComponent_li_3_a_2_Template(rf, ctx) { if (rf & 1) {
    var _r10 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "a", 7);
    ɵngcc0.ɵɵlistener("click", function ContextMenuContentComponent_li_3_a_2_Template_a_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); var menuItem_r2 = ɵngcc0.ɵɵnextContext().$implicit; var ctx_r8 = ɵngcc0.ɵɵnextContext(); return ctx_r8.onMenuItemSelect(menuItem_r2, $event); })("mouseenter", function ContextMenuContentComponent_li_3_a_2_Template_a_mouseenter_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r10); var menuItem_r2 = ɵngcc0.ɵɵnextContext().$implicit; var ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.onOpenSubMenu(menuItem_r2, $event); });
    ɵngcc0.ɵɵtemplate(1, ContextMenuContentComponent_li_3_a_2_ng_template_1_Template, 0, 0, "ng-template", 8);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var menuItem_r2 = ɵngcc0.ɵɵnextContext().$implicit;
    var ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("dropdown-item", ctx_r5.useBootstrap4)("active", menuItem_r2.isActive && ctx_r5.isMenuItemEnabled(menuItem_r2))("disabled", ctx_r5.useBootstrap4 && !ctx_r5.isMenuItemEnabled(menuItem_r2))("hasSubMenu", !!menuItem_r2.subMenu);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", menuItem_r2.template)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(10, _c2, ctx_r5.item));
} }
function ContextMenuContentComponent_li_3_span_3_ng_template_1_Template(rf, ctx) { }
function ContextMenuContentComponent_li_3_span_3_Template(rf, ctx) { if (rf & 1) {
    var _r16 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "span", 9);
    ɵngcc0.ɵɵlistener("click", function ContextMenuContentComponent_li_3_span_3_Template_span_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r16); var ctx_r15 = ɵngcc0.ɵɵnextContext(2); return ctx_r15.stopEvent($event); })("contextmenu", function ContextMenuContentComponent_li_3_span_3_Template_span_contextmenu_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r16); var ctx_r17 = ɵngcc0.ɵɵnextContext(2); return ctx_r17.stopEvent($event); });
    ɵngcc0.ɵɵtemplate(1, ContextMenuContentComponent_li_3_span_3_ng_template_1_Template, 0, 0, "ng-template", 8);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var menuItem_r2 = ɵngcc0.ɵɵnextContext().$implicit;
    var ctx_r6 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("dropdown-item", ctx_r6.useBootstrap4)("disabled", ctx_r6.useBootstrap4 && !ctx_r6.isMenuItemEnabled(menuItem_r2));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", menuItem_r2.template)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(6, _c2, ctx_r6.item));
} }
function ContextMenuContentComponent_li_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "li", null, 4);
    ɵngcc0.ɵɵtemplate(2, ContextMenuContentComponent_li_3_a_2_Template, 2, 12, "a", 5);
    ɵngcc0.ɵɵtemplate(3, ContextMenuContentComponent_li_3_span_3_Template, 2, 8, "span", 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var menuItem_r2 = ctx.$implicit;
    var ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("disabled", !ctx_r1.isMenuItemEnabled(menuItem_r2))("divider", menuItem_r2.divider)("dropdown-divider", ctx_r1.useBootstrap4 && menuItem_r2.divider)("active", menuItem_r2.isActive && ctx_r1.isMenuItemEnabled(menuItem_r2));
    ɵngcc0.ɵɵattribute("role", menuItem_r2.divider ? "separator" : undefined);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", !menuItem_r2.divider && !menuItem_r2.passive);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !menuItem_r2.divider && menuItem_r2.passive);
} }
'use strict';

  var CONTEXT_MENU_OPTIONS = new core.InjectionToken('CONTEXT_MENU_OPTIONS');

  var ARROW_LEFT_KEYCODE = 37;
  var ContextMenuContentComponent = /** @class */ (function () {
      function ContextMenuContentComponent(changeDetector, elementRef, options) {
          this.changeDetector = changeDetector;
          this.elementRef = elementRef;
          this.options = options;
          this.menuItems = [];
          this.isLeaf = false;
          this.execute = new core.EventEmitter();
          this.openSubMenu = new core.EventEmitter();
          this.closeLeafMenu = new core.EventEmitter();
          this.closeAllMenus = new core.EventEmitter();
          this.autoFocus = false;
          this.useBootstrap4 = false;
          this.subscription = new rxjs.Subscription();
          if (options) {
              this.autoFocus = options.autoFocus;
              this.useBootstrap4 = options.useBootstrap4;
          }
      }
      ContextMenuContentComponent.prototype.ngOnInit = function () {
          var _this = this;
          this.menuItems.forEach(function (menuItem) {
              menuItem.currentItem = _this.item;
              _this.subscription.add(menuItem.execute.subscribe(function (event) { return _this.execute.emit(Object.assign(Object.assign({}, event), { menuItem: menuItem })); }));
          });
          var queryList = new core.QueryList();
          queryList.reset(this.menuItems);
          this._keyManager = new a11y.ActiveDescendantKeyManager(queryList).withWrap();
      };
      ContextMenuContentComponent.prototype.ngAfterViewInit = function () {
          var _this = this;
          if (this.autoFocus) {
              setTimeout(function () { return _this.focus(); });
          }
          this.overlay.updatePosition();
      };
      ContextMenuContentComponent.prototype.ngOnDestroy = function () {
          this.subscription.unsubscribe();
      };
      ContextMenuContentComponent.prototype.focus = function () {
          if (this.autoFocus) {
              this.menuElement.nativeElement.focus();
          }
      };
      ContextMenuContentComponent.prototype.stopEvent = function ($event) {
          $event.stopPropagation();
      };
      ContextMenuContentComponent.prototype.isMenuItemEnabled = function (menuItem) {
          return this.evaluateIfFunction(menuItem && menuItem.enabled);
      };
      ContextMenuContentComponent.prototype.isMenuItemVisible = function (menuItem) {
          return this.evaluateIfFunction(menuItem && menuItem.visible);
      };
      ContextMenuContentComponent.prototype.evaluateIfFunction = function (value) {
          if (value instanceof Function) {
              return value(this.item);
          }
          return value;
      };
      ContextMenuContentComponent.prototype.isDisabled = function (link) {
          return link.enabled && !link.enabled(this.item);
      };
      ContextMenuContentComponent.prototype.onKeyEvent = function (event) {
          if (!this.isLeaf) {
              return;
          }
          this._keyManager.onKeydown(event);
      };
      ContextMenuContentComponent.prototype.keyboardOpenSubMenu = function (event) {
          if (!this.isLeaf) {
              return;
          }
          this.cancelEvent(event);
          var menuItem = this.menuItems[this._keyManager.activeItemIndex];
          if (menuItem) {
              this.onOpenSubMenu(menuItem);
          }
      };
      ContextMenuContentComponent.prototype.keyboardMenuItemSelect = function (event) {
          if (!this.isLeaf) {
              return;
          }
          this.cancelEvent(event);
          var menuItem = this.menuItems[this._keyManager.activeItemIndex];
          if (menuItem) {
              this.onMenuItemSelect(menuItem, event);
          }
      };
      ContextMenuContentComponent.prototype.onCloseLeafMenu = function (event) {
          if (!this.isLeaf) {
              return;
          }
          this.cancelEvent(event);
          this.closeLeafMenu.emit({
              exceptRootMenu: event.keyCode === ARROW_LEFT_KEYCODE,
              event: event
          });
      };
      ContextMenuContentComponent.prototype.closeMenu = function (event) {
          if (event.type === 'click' && event.button === 2) {
              return;
          }
          this.closeAllMenus.emit({ event: event });
      };
      ContextMenuContentComponent.prototype.onOpenSubMenu = function (menuItem, event) {
          var anchorElementRef = this.menuItemElements.toArray()[this._keyManager.activeItemIndex];
          var anchorElement = anchorElementRef && anchorElementRef.nativeElement;
          this.openSubMenu.emit({
              anchorElement: anchorElement,
              contextMenu: menuItem.subMenu,
              event: event,
              item: this.item,
              parentContextMenu: this
          });
      };
      ContextMenuContentComponent.prototype.onMenuItemSelect = function (menuItem, event) {
          event.preventDefault();
          event.stopPropagation();
          this.onOpenSubMenu(menuItem, event);
          if (!menuItem.subMenu) {
              menuItem.triggerExecute(this.item, event);
          }
      };
      ContextMenuContentComponent.prototype.cancelEvent = function (event) {
          if (!event) {
              return;
          }
          var target = event.target;
          if (['INPUT', 'TEXTAREA', 'SELECT'].indexOf(target.tagName) > -1 ||
              target.isContentEditable) {
              return;
          }
          event.preventDefault();
          event.stopPropagation();
      };
ContextMenuContentComponent.ɵfac = function ContextMenuContentComponent_Factory(t) { return new (t || ContextMenuContentComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(CONTEXT_MENU_OPTIONS, 8)); };
ContextMenuContentComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ContextMenuContentComponent, selectors: [["context-menu-content"]], viewQuery: function ContextMenuContentComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c0, true);
        ɵngcc0.ɵɵviewQuery(_c1, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.menuElement = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.menuItemElements = _t);
    } }, hostBindings: function ContextMenuContentComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown.ArrowDown", function ContextMenuContentComponent_keydown_ArrowDown_HostBindingHandler($event) { return ctx.onKeyEvent($event); }, false, ɵngcc0.ɵɵresolveWindow)("keydown.ArrowUp", function ContextMenuContentComponent_keydown_ArrowUp_HostBindingHandler($event) { return ctx.onKeyEvent($event); }, false, ɵngcc0.ɵɵresolveWindow)("keydown.ArrowRight", function ContextMenuContentComponent_keydown_ArrowRight_HostBindingHandler($event) { return ctx.keyboardOpenSubMenu($event); }, false, ɵngcc0.ɵɵresolveWindow)("keydown.Enter", function ContextMenuContentComponent_keydown_Enter_HostBindingHandler($event) { return ctx.keyboardMenuItemSelect($event); }, false, ɵngcc0.ɵɵresolveWindow)("keydown.Space", function ContextMenuContentComponent_keydown_Space_HostBindingHandler($event) { return ctx.keyboardMenuItemSelect($event); }, false, ɵngcc0.ɵɵresolveWindow)("keydown.Escape", function ContextMenuContentComponent_keydown_Escape_HostBindingHandler($event) { return ctx.onCloseLeafMenu($event); }, false, ɵngcc0.ɵɵresolveWindow)("keydown.ArrowLeft", function ContextMenuContentComponent_keydown_ArrowLeft_HostBindingHandler($event) { return ctx.onCloseLeafMenu($event); }, false, ɵngcc0.ɵɵresolveWindow)("click", function ContextMenuContentComponent_click_HostBindingHandler($event) { return ctx.closeMenu($event); }, false, ɵngcc0.ɵɵresolveDocument)("contextmenu", function ContextMenuContentComponent_contextmenu_HostBindingHandler($event) { return ctx.closeMenu($event); }, false, ɵngcc0.ɵɵresolveDocument);
    } }, inputs: { menuItems: "menuItems", isLeaf: "isLeaf", item: "item", event: "event", parentContextMenu: "parentContextMenu", menuClass: "menuClass", overlay: "overlay" }, outputs: { execute: "execute", openSubMenu: "openSubMenu", closeLeafMenu: "closeLeafMenu", closeAllMenus: "closeAllMenus" }, decls: 4, vars: 2, consts: [["tabindex", "0", 1, "dropdown", "open", "show", "ngx-contextmenu", 3, "ngClass"], ["tabindex", "0", 1, "dropdown-menu", "show", 2, "position", "static", "float", "none"], ["menu", ""], [3, "disabled", "divider", "dropdown-divider", "active", 4, "ngFor", "ngForOf"], ["li", ""], ["href", "", 3, "dropdown-item", "active", "disabled", "hasSubMenu", "click", "mouseenter", 4, "ngIf"], ["class", "passive", 3, "dropdown-item", "disabled", "click", "contextmenu", 4, "ngIf"], ["href", "", 3, "click", "mouseenter"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "passive", 3, "click", "contextmenu"]], template: function ContextMenuContentComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "ul", 1, 2);
        ɵngcc0.ɵɵtemplate(3, ContextMenuContentComponent_li_3_Template, 4, 11, "li", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", ctx.menuClass);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.menuItems);
    } }, directives: [ɵngcc1.NgClass, ɵngcc1.NgForOf, ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet], styles: [".passive[_ngcontent-%COMP%] {\n        display: block;\n        padding: 3px 20px;\n        clear: both;\n        font-weight: normal;\n        line-height: @line-height-base;\n        white-space: nowrap;\n      }\n      .hasSubMenu[_ngcontent-%COMP%]:before {\n        content: '\u25B6';\n        float: right;\n      }"] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ContextMenuContentComponent, [{
        type: core.Component,
        args: [{
                selector: 'context-menu-content',
                template: "\n    <div\n      class=\"dropdown open show ngx-contextmenu\"\n      [ngClass]=\"menuClass\"\n      tabindex=\"0\"\n    >\n      <ul\n        #menu\n        class=\"dropdown-menu show\"\n        style=\"position: static; float: none;\"\n        tabindex=\"0\"\n      >\n        <li\n          #li\n          *ngFor=\"let menuItem of menuItems; let i = index\"\n          [class.disabled]=\"!isMenuItemEnabled(menuItem)\"\n          [class.divider]=\"menuItem.divider\"\n          [class.dropdown-divider]=\"useBootstrap4 && menuItem.divider\"\n          [class.active]=\"menuItem.isActive && isMenuItemEnabled(menuItem)\"\n          [attr.role]=\"menuItem.divider ? 'separator' : undefined\"\n        >\n          <a\n            *ngIf=\"!menuItem.divider && !menuItem.passive\"\n            href\n            [class.dropdown-item]=\"useBootstrap4\"\n            [class.active]=\"menuItem.isActive && isMenuItemEnabled(menuItem)\"\n            [class.disabled]=\"useBootstrap4 && !isMenuItemEnabled(menuItem)\"\n            [class.hasSubMenu]=\"!!menuItem.subMenu\"\n            (click)=\"onMenuItemSelect(menuItem, $event)\"\n            (mouseenter)=\"onOpenSubMenu(menuItem, $event)\"\n          >\n            <ng-template\n              [ngTemplateOutlet]=\"menuItem.template\"\n              [ngTemplateOutletContext]=\"{ $implicit: item }\"\n            ></ng-template>\n          </a>\n\n          <span\n            (click)=\"stopEvent($event)\"\n            (contextmenu)=\"stopEvent($event)\"\n            class=\"passive\"\n            *ngIf=\"!menuItem.divider && menuItem.passive\"\n            [class.dropdown-item]=\"useBootstrap4\"\n            [class.disabled]=\"useBootstrap4 && !isMenuItemEnabled(menuItem)\"\n          >\n            <ng-template\n              [ngTemplateOutlet]=\"menuItem.template\"\n              [ngTemplateOutletContext]=\"{ $implicit: item }\"\n            ></ng-template>\n          </span>\n        </li>\n      </ul>\n    </div>\n  ",
                styles: ["\n      .passive {\n        display: block;\n        padding: 3px 20px;\n        clear: both;\n        font-weight: normal;\n        line-height: @line-height-base;\n        white-space: nowrap;\n      }\n      .hasSubMenu:before {\n        content: '\u25B6';\n        float: right;\n      }\n    "]
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: undefined, decorators: [{
                type: core.Optional
            }, {
                type: core.Inject,
                args: [CONTEXT_MENU_OPTIONS]
            }] }]; }, { menuItems: [{
            type: core.Input
        }], isLeaf: [{
            type: core.Input
        }], execute: [{
            type: core.Output
        }], openSubMenu: [{
            type: core.Output
        }], closeLeafMenu: [{
            type: core.Output
        }], closeAllMenus: [{
            type: core.Output
        }], onKeyEvent: [{
            type: core.HostListener,
            args: ['window:keydown.ArrowDown', ['$event']]
        }, {
            type: core.HostListener,
            args: ['window:keydown.ArrowUp', ['$event']]
        }], keyboardOpenSubMenu: [{
            type: core.HostListener,
            args: ['window:keydown.ArrowRight', ['$event']]
        }], keyboardMenuItemSelect: [{
            type: core.HostListener,
            args: ['window:keydown.Enter', ['$event']]
        }, {
            type: core.HostListener,
            args: ['window:keydown.Space', ['$event']]
        }], onCloseLeafMenu: [{
            type: core.HostListener,
            args: ['window:keydown.Escape', ['$event']]
        }, {
            type: core.HostListener,
            args: ['window:keydown.ArrowLeft', ['$event']]
        }], closeMenu: [{
            type: core.HostListener,
            args: ['document:click', ['$event']]
        }, {
            type: core.HostListener,
            args: ['document:contextmenu', ['$event']]
        }], item: [{
            type: core.Input
        }], event: [{
            type: core.Input
        }], parentContextMenu: [{
            type: core.Input
        }], menuClass: [{
            type: core.Input
        }], overlay: [{
            type: core.Input
        }], menuElement: [{
            type: core.ViewChild,
            args: ['menu', { static: true }]
        }], menuItemElements: [{
            type: core.ViewChildren,
            args: ['li']
        }] }); })();
      return ContextMenuContentComponent;
  }());
  /** @nocollapse */
  ContextMenuContentComponent.ctorParameters = function () { return [
      { type: core.ChangeDetectorRef },
      { type: core.ElementRef },
      { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [CONTEXT_MENU_OPTIONS,] }] }
  ]; };
  ContextMenuContentComponent.propDecorators = {
      menuItems: [{ type: core.Input }],
      item: [{ type: core.Input }],
      event: [{ type: core.Input }],
      parentContextMenu: [{ type: core.Input }],
      menuClass: [{ type: core.Input }],
      overlay: [{ type: core.Input }],
      isLeaf: [{ type: core.Input }],
      execute: [{ type: core.Output }],
      openSubMenu: [{ type: core.Output }],
      closeLeafMenu: [{ type: core.Output }],
      closeAllMenus: [{ type: core.Output }],
      menuElement: [{ type: core.ViewChild, args: ['menu', { static: true },] }],
      menuItemElements: [{ type: core.ViewChildren, args: ['li',] }],
      onKeyEvent: [{ type: core.HostListener, args: ['window:keydown.ArrowDown', ['$event'],] }, { type: core.HostListener, args: ['window:keydown.ArrowUp', ['$event'],] }],
      keyboardOpenSubMenu: [{ type: core.HostListener, args: ['window:keydown.ArrowRight', ['$event'],] }],
      keyboardMenuItemSelect: [{ type: core.HostListener, args: ['window:keydown.Enter', ['$event'],] }, { type: core.HostListener, args: ['window:keydown.Space', ['$event'],] }],
      onCloseLeafMenu: [{ type: core.HostListener, args: ['window:keydown.Escape', ['$event'],] }, { type: core.HostListener, args: ['window:keydown.ArrowLeft', ['$event'],] }],
      closeMenu: [{ type: core.HostListener, args: ['document:click', ['$event'],] }, { type: core.HostListener, args: ['document:contextmenu', ['$event'],] }]
  };

  var ContextMenuService = /** @class */ (function () {
      function ContextMenuService(overlay, scrollStrategy) {
          this.overlay = overlay;
          this.scrollStrategy = scrollStrategy;
          this.isDestroyingLeafMenu = false;
          this.show = new rxjs.Subject();
          this.triggerClose = new rxjs.Subject();
          this.close = new rxjs.Subject();
          this.overlays = [];
          this.fakeElement = {
              getBoundingClientRect: function () { return ({
                  bottom: 0,
                  height: 0,
                  left: 0,
                  right: 0,
                  top: 0,
                  width: 0,
              }); }
          };
      }
      ContextMenuService.prototype.openContextMenu = function (context) {
          var anchorElement = context.anchorElement, event = context.event, parentContextMenu = context.parentContextMenu;
          if (!parentContextMenu) {
              var mouseEvent_1 = event;
              this.fakeElement.getBoundingClientRect = function () { return ({
                  bottom: mouseEvent_1.clientY,
                  height: 0,
                  left: mouseEvent_1.clientX,
                  right: mouseEvent_1.clientX,
                  top: mouseEvent_1.clientY,
                  width: 0,
              }); };
              this.closeAllContextMenus({ eventType: 'cancel', event: event });
              var positionStrategy = this.overlay.position().connectedTo(new core.ElementRef(anchorElement || this.fakeElement), { originX: 'start', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' })
                  .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' })
                  .withFallbackPosition({ originX: 'end', originY: 'top' }, { overlayX: 'start', overlayY: 'top' })
                  .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'end', overlayY: 'top' })
                  .withFallbackPosition({ originX: 'end', originY: 'center' }, { overlayX: 'start', overlayY: 'center' })
                  .withFallbackPosition({ originX: 'start', originY: 'center' }, { overlayX: 'end', overlayY: 'center' });
              this.overlays = [this.overlay.create({
                      positionStrategy: positionStrategy,
                      panelClass: 'ngx-contextmenu',
                      scrollStrategy: this.scrollStrategy.close(),
                  })];
              this.attachContextMenu(this.overlays[0], context);
          }
          else {
              var positionStrategy = this.overlay.position().connectedTo(new core.ElementRef(event ? event.target : anchorElement), { originX: 'end', originY: 'top' }, { overlayX: 'start', overlayY: 'top' })
                  .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'end', overlayY: 'top' })
                  .withFallbackPosition({ originX: 'end', originY: 'bottom' }, { overlayX: 'start', overlayY: 'bottom' })
                  .withFallbackPosition({ originX: 'start', originY: 'bottom' }, { overlayX: 'end', overlayY: 'bottom' });
              var newOverlay = this.overlay.create({
                  positionStrategy: positionStrategy,
                  panelClass: 'ngx-contextmenu',
                  scrollStrategy: this.scrollStrategy.close(),
              });
              this.destroySubMenus(parentContextMenu);
              this.overlays = this.overlays.concat(newOverlay);
              this.attachContextMenu(newOverlay, context);
          }
      };
      ContextMenuService.prototype.attachContextMenu = function (overlay, context) {
          var _this = this;
          var event = context.event, item = context.item, menuItems = context.menuItems, menuClass = context.menuClass;
          var contextMenuContent = overlay.attach(new portal.ComponentPortal(ContextMenuContentComponent));
          contextMenuContent.instance.event = event;
          contextMenuContent.instance.item = item;
          contextMenuContent.instance.menuItems = menuItems;
          contextMenuContent.instance.overlay = overlay;
          contextMenuContent.instance.isLeaf = true;
          contextMenuContent.instance.menuClass = menuClass;
          overlay.contextMenu = contextMenuContent.instance;
          var subscriptions = new rxjs.Subscription();
          subscriptions.add(contextMenuContent.instance.execute.asObservable()
              .subscribe(function (executeEvent) { return _this.closeAllContextMenus(Object.assign({ eventType: 'execute' }, executeEvent)); }));
          subscriptions.add(contextMenuContent.instance.closeAllMenus.asObservable()
              .subscribe(function (closeAllEvent) { return _this.closeAllContextMenus(Object.assign({ eventType: 'cancel' }, closeAllEvent)); }));
          subscriptions.add(contextMenuContent.instance.closeLeafMenu.asObservable()
              .subscribe(function (closeLeafMenuEvent) { return _this.destroyLeafMenu(closeLeafMenuEvent); }));
          subscriptions.add(contextMenuContent.instance.openSubMenu.asObservable()
              .subscribe(function (subMenuEvent) {
              _this.destroySubMenus(contextMenuContent.instance);
              if (!subMenuEvent.contextMenu) {
                  contextMenuContent.instance.isLeaf = true;
                  return;
              }
              contextMenuContent.instance.isLeaf = false;
              _this.show.next(subMenuEvent);
          }));
          contextMenuContent.onDestroy(function () {
              menuItems.forEach(function (menuItem) { return menuItem.isActive = false; });
              subscriptions.unsubscribe();
          });
          contextMenuContent.changeDetectorRef.detectChanges();
      };
      ContextMenuService.prototype.closeAllContextMenus = function (closeEvent) {
          if (this.overlays) {
              this.close.next(closeEvent);
              this.overlays.forEach(function (overlay, index) {
                  overlay.detach();
                  overlay.dispose();
              });
          }
          this.overlays = [];
      };
      ContextMenuService.prototype.getLastAttachedOverlay = function () {
          var overlay = this.overlays[this.overlays.length - 1];
          while (this.overlays.length > 1 && overlay && !overlay.hasAttached()) {
              overlay.detach();
              overlay.dispose();
              this.overlays = this.overlays.slice(0, -1);
              overlay = this.overlays[this.overlays.length - 1];
          }
          return overlay;
      };
      ContextMenuService.prototype.destroyLeafMenu = function (_a) {
          var _this = this;
          var _b = _a === void 0 ? {} : _a, exceptRootMenu = _b.exceptRootMenu, event = _b.event;
          if (this.isDestroyingLeafMenu) {
              return;
          }
          this.isDestroyingLeafMenu = true;
          setTimeout(function () {
              var overlay = _this.getLastAttachedOverlay();
              if (_this.overlays.length > 1 && overlay) {
                  overlay.detach();
                  overlay.dispose();
              }
              if (!exceptRootMenu && _this.overlays.length > 0 && overlay) {
                  _this.close.next({ eventType: 'cancel', event: event });
                  overlay.detach();
                  overlay.dispose();
              }
              var newLeaf = _this.getLastAttachedOverlay();
              if (newLeaf) {
                  newLeaf.contextMenu.isLeaf = true;
              }
              _this.isDestroyingLeafMenu = false;
          });
      };
      ContextMenuService.prototype.destroySubMenus = function (contextMenu) {
          var overlay = contextMenu.overlay;
          var index = this.overlays.indexOf(overlay);
          this.overlays.slice(index + 1).forEach(function (subMenuOverlay) {
              subMenuOverlay.detach();
              subMenuOverlay.dispose();
          });
      };
      ContextMenuService.prototype.isLeafMenu = function (contextMenuContent) {
          var overlay = this.getLastAttachedOverlay();
          return contextMenuContent.overlay === overlay;
      };
ContextMenuService.ɵfac = function ContextMenuService_Factory(t) { return new (t || ContextMenuService)(ɵngcc0.ɵɵinject(ɵngcc2.Overlay), ɵngcc0.ɵɵinject(ɵngcc2.ScrollStrategyOptions)); };
ContextMenuService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ContextMenuService, factory: function (t) { return ContextMenuService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ContextMenuService, [{
        type: core.Injectable
    }], function () { return [{ type: ɵngcc2.Overlay }, { type: ɵngcc2.ScrollStrategyOptions }]; }, null); })();
      return ContextMenuService;
  }());
  /** @nocollapse */
  ContextMenuService.ctorParameters = function () { return [
      { type: overlay.Overlay },
      { type: overlay.ScrollStrategyOptions }
  ]; };

  var ContextMenuAttachDirective = /** @class */ (function () {
      function ContextMenuAttachDirective(contextMenuService) {
          this.contextMenuService = contextMenuService;
      }
      ContextMenuAttachDirective.prototype.onContextMenu = function (event) {
          if (!this.contextMenu.disabled) {
              this.contextMenuService.show.next({
                  contextMenu: this.contextMenu,
                  event: event,
                  item: this.contextMenuSubject,
              });
              event.preventDefault();
              event.stopPropagation();
          }
      };
ContextMenuAttachDirective.ɵfac = function ContextMenuAttachDirective_Factory(t) { return new (t || ContextMenuAttachDirective)(ɵngcc0.ɵɵdirectiveInject(ContextMenuService)); };
ContextMenuAttachDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ContextMenuAttachDirective, selectors: [["", "contextMenu", ""]], hostBindings: function ContextMenuAttachDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("contextmenu", function ContextMenuAttachDirective_contextmenu_HostBindingHandler($event) { return ctx.onContextMenu($event); });
    } }, inputs: { contextMenuSubject: "contextMenuSubject", contextMenu: "contextMenu" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ContextMenuAttachDirective, [{
        type: core.Directive,
        args: [{
                selector: '[contextMenu]'
            }]
    }], function () { return [{ type: ContextMenuService }]; }, { onContextMenu: [{
            type: core.HostListener,
            args: ['contextmenu', ['$event']]
        }], contextMenuSubject: [{
            type: core.Input
        }], contextMenu: [{
            type: core.Input
        }] }); })();
      return ContextMenuAttachDirective;
  }());
  /** @nocollapse */
  ContextMenuAttachDirective.ctorParameters = function () { return [
      { type: ContextMenuService }
  ]; };
  ContextMenuAttachDirective.propDecorators = {
      contextMenuSubject: [{ type: core.Input }],
      contextMenu: [{ type: core.Input }],
      onContextMenu: [{ type: core.HostListener, args: ['contextmenu', ['$event'],] }]
  };

  var ContextMenuItemDirective = /** @class */ (function () {
      function ContextMenuItemDirective(template, elementRef) {
          this.template = template;
          this.elementRef = elementRef;
          this.divider = false;
          this.enabled = true;
          this.passive = false;
          this.visible = true;
          this.execute = new core.EventEmitter();
          this.isActive = false;
      }
      Object.defineProperty(ContextMenuItemDirective.prototype, "disabled", {
          get: function () {
              return this.passive ||
                  this.divider ||
                  !this.evaluateIfFunction(this.enabled, this.currentItem);
          },
          enumerable: false,
          configurable: true
      });
      ContextMenuItemDirective.prototype.evaluateIfFunction = function (value, item) {
          if (value instanceof Function) {
              return value(item);
          }
          return value;
      };
      ContextMenuItemDirective.prototype.setActiveStyles = function () {
          this.isActive = true;
      };
      ContextMenuItemDirective.prototype.setInactiveStyles = function () {
          this.isActive = false;
      };
      ContextMenuItemDirective.prototype.triggerExecute = function (item, $event) {
          if (!this.evaluateIfFunction(this.enabled, item)) {
              return;
          }
          this.execute.emit({ event: $event, item: item });
      };
ContextMenuItemDirective.ɵfac = function ContextMenuItemDirective_Factory(t) { return new (t || ContextMenuItemDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
ContextMenuItemDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ContextMenuItemDirective, selectors: [["", "contextMenuItem", ""]], inputs: { divider: "divider", enabled: "enabled", passive: "passive", visible: "visible", subMenu: "subMenu" }, outputs: { execute: "execute" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ContextMenuItemDirective, [{
        type: core.Directive,
        args: [{
                /* tslint:disable:directive-selector-type */
                selector: '[contextMenuItem]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }, { type: ɵngcc0.ElementRef }]; }, { divider: [{
            type: core.Input
        }], enabled: [{
            type: core.Input
        }], passive: [{
            type: core.Input
        }], visible: [{
            type: core.Input
        }], execute: [{
            type: core.Output
        }], subMenu: [{
            type: core.Input
        }] }); })();
      return ContextMenuItemDirective;
  }());
  /** @nocollapse */
  ContextMenuItemDirective.ctorParameters = function () { return [
      { type: core.TemplateRef },
      { type: core.ElementRef }
  ]; };
  ContextMenuItemDirective.propDecorators = {
      subMenu: [{ type: core.Input }],
      divider: [{ type: core.Input }],
      enabled: [{ type: core.Input }],
      passive: [{ type: core.Input }],
      visible: [{ type: core.Input }],
      execute: [{ type: core.Output }]
  };

  var ContextMenuComponent = /** @class */ (function () {
      function ContextMenuComponent(_contextMenuService, changeDetector, elementRef, options) {
          var _this = this;
          this._contextMenuService = _contextMenuService;
          this.changeDetector = changeDetector;
          this.elementRef = elementRef;
          this.options = options;
          this.menuClass = "";
          this.autoFocus = false;
          this.useBootstrap4 = false;
          this.disabled = false;
          this.close = new core.EventEmitter();
          this.open = new core.EventEmitter();
          this.visibleMenuItems = [];
          this.links = [];
          this.subscription = new rxjs.Subscription();
          if (options) {
              this.autoFocus = options.autoFocus;
              this.useBootstrap4 = options.useBootstrap4;
          }
          this.subscription.add(_contextMenuService.show.subscribe(function (menuEvent) {
              _this.onMenuEvent(menuEvent);
          }));
      }
      ContextMenuComponent.prototype.ngOnDestroy = function () {
          this.subscription.unsubscribe();
      };
      ContextMenuComponent.prototype.onMenuEvent = function (menuEvent) {
          var _this = this;
          if (this.disabled) {
              return;
          }
          var contextMenu = menuEvent.contextMenu, event = menuEvent.event, item = menuEvent.item;
          if (contextMenu && contextMenu !== this) {
              return;
          }
          this.event = event;
          this.item = item;
          this.setVisibleMenuItems();
          this._contextMenuService.openContextMenu(Object.assign(Object.assign({}, menuEvent), { menuItems: this.visibleMenuItems, menuClass: this.menuClass }));
          this._contextMenuService.close.asObservable().pipe(operators.first()).subscribe(function (closeEvent) { return _this.close.emit(closeEvent); });
          this.open.next(menuEvent);
      };
      ContextMenuComponent.prototype.isMenuItemVisible = function (menuItem) {
          return this.evaluateIfFunction(menuItem.visible);
      };
      ContextMenuComponent.prototype.setVisibleMenuItems = function () {
          var _this = this;
          this.visibleMenuItems = this.menuItems.filter(function (menuItem) { return _this.isMenuItemVisible(menuItem); });
      };
      ContextMenuComponent.prototype.evaluateIfFunction = function (value) {
          if (value instanceof Function) {
              return value(this.item);
          }
          return value;
      };
ContextMenuComponent.ɵfac = function ContextMenuComponent_Factory(t) { return new (t || ContextMenuComponent)(ɵngcc0.ɵɵdirectiveInject(ContextMenuService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(CONTEXT_MENU_OPTIONS, 8)); };
ContextMenuComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ContextMenuComponent, selectors: [["context-menu"]], contentQueries: function ContextMenuComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ContextMenuItemDirective, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.menuItems = _t);
    } }, viewQuery: function ContextMenuComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.menuElement = _t.first);
    } }, inputs: { menuClass: "menuClass", autoFocus: "autoFocus", useBootstrap4: "useBootstrap4", disabled: "disabled" }, outputs: { close: "close", open: "open" }, decls: 0, vars: 0, template: function ContextMenuComponent_Template(rf, ctx) { }, styles: ["\n    .cdk-overlay-container {\n      position: fixed;\n      z-index: 1000;\n      pointer-events: none;\n      top: 0;\n      left: 0;\n      width: 100%;\n      height: 100%;\n    }\n    .ngx-contextmenu.cdk-overlay-pane {\n      position: absolute;\n      pointer-events: auto;\n      box-sizing: border-box;\n    }\n  "], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ContextMenuComponent, [{
        type: core.Component,
        args: [{
                encapsulation: core.ViewEncapsulation.None,
                selector: 'context-menu',
                template: " ",
                styles: ["\n    .cdk-overlay-container {\n      position: fixed;\n      z-index: 1000;\n      pointer-events: none;\n      top: 0;\n      left: 0;\n      width: 100%;\n      height: 100%;\n    }\n    .ngx-contextmenu.cdk-overlay-pane {\n      position: absolute;\n      pointer-events: auto;\n      box-sizing: border-box;\n    }\n  "]
            }]
    }], function () { return [{ type: ContextMenuService }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: undefined, decorators: [{
                type: core.Optional
            }, {
                type: core.Inject,
                args: [CONTEXT_MENU_OPTIONS]
            }] }]; }, { menuClass: [{
            type: core.Input
        }], autoFocus: [{
            type: core.Input
        }], useBootstrap4: [{
            type: core.Input
        }], disabled: [{
            type: core.Input
        }], close: [{
            type: core.Output
        }], open: [{
            type: core.Output
        }], menuItems: [{
            type: core.ContentChildren,
            args: [ContextMenuItemDirective]
        }], menuElement: [{
            type: core.ViewChild,
            args: ['menu', { static: false }]
        }] }); })();
      return ContextMenuComponent;
  }());
  /** @nocollapse */
  ContextMenuComponent.ctorParameters = function () { return [
      { type: ContextMenuService },
      { type: core.ChangeDetectorRef },
      { type: core.ElementRef },
      { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [CONTEXT_MENU_OPTIONS,] }] }
  ]; };
  ContextMenuComponent.propDecorators = {
      menuClass: [{ type: core.Input }],
      autoFocus: [{ type: core.Input }],
      useBootstrap4: [{ type: core.Input }],
      disabled: [{ type: core.Input }],
      close: [{ type: core.Output }],
      open: [{ type: core.Output }],
      menuItems: [{ type: core.ContentChildren, args: [ContextMenuItemDirective,] }],
      menuElement: [{ type: core.ViewChild, args: ['menu', { static: false },] }]
  };

  var ContextMenuModule = /** @class */ (function () {
      function ContextMenuModule() {
      }
      ContextMenuModule.forRoot = function (options) {
          return {
              ngModule: ContextMenuModule,
              providers: [
                  ContextMenuService,
                  {
                      provide: CONTEXT_MENU_OPTIONS,
                      useValue: options,
                  },
                  { provide: overlay.OverlayContainer, useClass: overlay.FullscreenOverlayContainer },
              ],
          };
      };
ContextMenuModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ContextMenuModule });
ContextMenuModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ContextMenuModule_Factory(t) { return new (t || ContextMenuModule)(); }, imports: [[
            common.CommonModule,
            overlay.OverlayModule,
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ContextMenuModule, { declarations: [ContextMenuAttachDirective, ContextMenuComponent, ContextMenuContentComponent, ContextMenuItemDirective], imports: [ɵngcc1.CommonModule, ɵngcc2.OverlayModule], exports: [ContextMenuAttachDirective, ContextMenuComponent, ContextMenuItemDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ContextMenuModule, [{
        type: core.NgModule,
        args: [{
                declarations: [
                    ContextMenuAttachDirective,
                    ContextMenuComponent,
                    ContextMenuContentComponent,
                    ContextMenuItemDirective,
                ],
                entryComponents: [
                    ContextMenuContentComponent,
                ],
                exports: [
                    ContextMenuAttachDirective,
                    ContextMenuComponent,
                    ContextMenuItemDirective,
                ],
                imports: [
                    common.CommonModule,
                    overlay.OverlayModule,
                ]
            }]
    }], function () { return []; }, null); })();
      return ContextMenuModule;
  }());

  /*
   * Public API Surface of ngx-contextmenu
   */

  /**
   * Generated bundle index. Do not edit.
   */

  exports.ContextMenuAttachDirective = ContextMenuAttachDirective;
  exports.ContextMenuComponent = ContextMenuComponent;
  exports.ContextMenuItemDirective = ContextMenuItemDirective;
  exports.ContextMenuModule = ContextMenuModule;
  exports.ContextMenuService = ContextMenuService;
  exports.ɵa = CONTEXT_MENU_OPTIONS;
  exports.ɵb = ContextMenuContentComponent;

  Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=ngx-contextmenu.umd.js.map