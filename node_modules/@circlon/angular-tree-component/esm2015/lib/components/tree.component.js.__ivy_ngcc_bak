/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/tree.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, ContentChild, EventEmitter, HostListener, Input, Output, TemplateRef, ViewChild } from '@angular/core';
import { TreeModel } from '../models/tree.model';
import { TreeDraggedElement } from '../models/tree-dragged-element.model';
import { TreeViewportComponent } from './tree-viewport.component';
import { includes, pick } from 'lodash-es';
export class TreeComponent {
    /**
     * @param {?} treeModel
     * @param {?} treeDraggedElement
     */
    constructor(treeModel, treeDraggedElement) {
        this.treeModel = treeModel;
        this.treeDraggedElement = treeDraggedElement;
        treeModel.eventNames.forEach((/**
         * @param {?} name
         * @return {?}
         */
        (name) => this[name] = new EventEmitter()));
        treeModel.subscribeToState((/**
         * @param {?} state
         * @return {?}
         */
        (state) => this.stateChange.emit(state)));
    }
    // Will be handled in ngOnChanges
    /**
     * @param {?} nodes
     * @return {?}
     */
    set nodes(nodes) {
    }
    ;
    /**
     * @param {?} options
     * @return {?}
     */
    set options(options) {
    }
    ;
    /**
     * @param {?} value
     * @return {?}
     */
    set focused(value) {
        this.treeModel.setFocus(value);
    }
    /**
     * @param {?} state
     * @return {?}
     */
    set state(state) {
        this.treeModel.setState(state);
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onKeydown($event) {
        if (!this.treeModel.isFocused)
            return;
        if (includes(['input', 'textarea'], document.activeElement.tagName.toLowerCase()))
            return;
        /** @type {?} */
        const focusedNode = this.treeModel.getFocusedNode();
        this.treeModel.performKeyAction(focusedNode, $event);
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onMousedown($event) {
        /**
         * @param {?} startElement
         * @param {?} nodeName
         * @return {?}
         */
        function isOutsideClick(startElement, nodeName) {
            return !startElement ? true : startElement.localName === nodeName ? false : isOutsideClick(startElement.parentElement, nodeName);
        }
        if (isOutsideClick($event.target, 'tree-root')) {
            this.treeModel.setFocus(false);
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.options || changes.nodes) {
            this.treeModel.setData({
                options: changes.options && changes.options.currentValue,
                nodes: changes.nodes && changes.nodes.currentValue,
                events: pick(this, this.treeModel.eventNames)
            });
        }
    }
    /**
     * @return {?}
     */
    sizeChanged() {
        this.viewportComponent.setViewport();
    }
}
TreeComponent.decorators = [
    { type: Component, args: [{
                selector: 'Tree, tree-root',
                providers: [TreeModel],
                template: `
      <tree-viewport #viewport>
          <div
                  class="angular-tree-component"
                  [class.node-dragging]="treeDraggedElement.isDragging()"
                  [class.angular-tree-component-rtl]="treeModel.options.rtl">
              <tree-node-collection
                      *ngIf="treeModel.roots"
                      [nodes]="treeModel.roots"
                      [treeModel]="treeModel"
                      [templates]="{
            loadingTemplate: loadingTemplate,
            treeNodeTemplate: treeNodeTemplate,
            treeNodeWrapperTemplate: treeNodeWrapperTemplate,
            treeNodeFullTemplate: treeNodeFullTemplate
          }">
              </tree-node-collection>
              <tree-node-drop-slot
                      class="empty-tree-drop-slot"
                      *ngIf="treeModel.isEmptyTree()"
                      [dropIndex]="0"
                      [node]="treeModel.virtualRoot">
              </tree-node-drop-slot>
          </div>
      </tree-viewport>
  `
            }] }
];
/** @nocollapse */
TreeComponent.ctorParameters = () => [
    { type: TreeModel },
    { type: TreeDraggedElement }
];
TreeComponent.propDecorators = {
    loadingTemplate: [{ type: ContentChild, args: ['loadingTemplate', { static: false },] }],
    treeNodeTemplate: [{ type: ContentChild, args: ['treeNodeTemplate', { static: false },] }],
    treeNodeWrapperTemplate: [{ type: ContentChild, args: ['treeNodeWrapperTemplate', { static: false },] }],
    treeNodeFullTemplate: [{ type: ContentChild, args: ['treeNodeFullTemplate', { static: false },] }],
    viewportComponent: [{ type: ViewChild, args: ['viewport', { static: false },] }],
    nodes: [{ type: Input }],
    options: [{ type: Input }],
    focused: [{ type: Input }],
    state: [{ type: Input }],
    toggleExpanded: [{ type: Output }],
    activate: [{ type: Output }],
    deactivate: [{ type: Output }],
    nodeActivate: [{ type: Output }],
    nodeDeactivate: [{ type: Output }],
    select: [{ type: Output }],
    deselect: [{ type: Output }],
    focus: [{ type: Output }],
    blur: [{ type: Output }],
    updateData: [{ type: Output }],
    initialized: [{ type: Output }],
    moveNode: [{ type: Output }],
    copyNode: [{ type: Output }],
    loadNodeChildren: [{ type: Output }],
    changeFilter: [{ type: Output }],
    event: [{ type: Output }],
    stateChange: [{ type: Output }],
    onKeydown: [{ type: HostListener, args: ['body: keydown', ['$event'],] }],
    onMousedown: [{ type: HostListener, args: ['body: mousedown', ['$event'],] }]
};
if (false) {
    /** @type {?} */
    TreeComponent.prototype._nodes;
    /** @type {?} */
    TreeComponent.prototype._options;
    /** @type {?} */
    TreeComponent.prototype.loadingTemplate;
    /** @type {?} */
    TreeComponent.prototype.treeNodeTemplate;
    /** @type {?} */
    TreeComponent.prototype.treeNodeWrapperTemplate;
    /** @type {?} */
    TreeComponent.prototype.treeNodeFullTemplate;
    /** @type {?} */
    TreeComponent.prototype.viewportComponent;
    /** @type {?} */
    TreeComponent.prototype.toggleExpanded;
    /** @type {?} */
    TreeComponent.prototype.activate;
    /** @type {?} */
    TreeComponent.prototype.deactivate;
    /** @type {?} */
    TreeComponent.prototype.nodeActivate;
    /** @type {?} */
    TreeComponent.prototype.nodeDeactivate;
    /** @type {?} */
    TreeComponent.prototype.select;
    /** @type {?} */
    TreeComponent.prototype.deselect;
    /** @type {?} */
    TreeComponent.prototype.focus;
    /** @type {?} */
    TreeComponent.prototype.blur;
    /** @type {?} */
    TreeComponent.prototype.updateData;
    /** @type {?} */
    TreeComponent.prototype.initialized;
    /** @type {?} */
    TreeComponent.prototype.moveNode;
    /** @type {?} */
    TreeComponent.prototype.copyNode;
    /** @type {?} */
    TreeComponent.prototype.loadNodeChildren;
    /** @type {?} */
    TreeComponent.prototype.changeFilter;
    /** @type {?} */
    TreeComponent.prototype.event;
    /** @type {?} */
    TreeComponent.prototype.stateChange;
    /** @type {?} */
    TreeComponent.prototype.treeModel;
    /** @type {?} */
    TreeComponent.prototype.treeDraggedElement;
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9hbmd1bGFyLXRyZWUtY29tcG9uZW50L3NyYy9saWIvY29tcG9uZW50cy90cmVlLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsWUFBWSxFQUFFLFlBQVksRUFBRSxZQUFZLEVBQUUsS0FBSyxFQUFhLE1BQU0sRUFBRSxXQUFXLEVBQUUsU0FBUyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3RJLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUNqRCxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxzQ0FBc0MsQ0FBQztBQUcxRSxPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUVsRSxPQUFPLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxNQUFNLFdBQVcsQ0FBQztBQWlDM0MsTUFBTSxPQUFPLGFBQWE7Ozs7O0lBMkN4QixZQUNTLFNBQW9CLEVBQ3BCLGtCQUFzQztRQUR0QyxjQUFTLEdBQVQsU0FBUyxDQUFXO1FBQ3BCLHVCQUFrQixHQUFsQixrQkFBa0IsQ0FBb0I7UUFFN0MsU0FBUyxDQUFDLFVBQVUsQ0FBQyxPQUFPOzs7O1FBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxJQUFJLFlBQVksRUFBRSxFQUFDLENBQUM7UUFDeEUsU0FBUyxDQUFDLGdCQUFnQjs7OztRQUFDLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBQyxDQUFDO0lBQ3RFLENBQUM7Ozs7OztJQXRDRCxJQUFhLEtBQUssQ0FBQyxLQUFZO0lBQy9CLENBQUM7SUFBQSxDQUFDOzs7OztJQUVGLElBQWEsT0FBTyxDQUFDLE9B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QU07dUJBQ04sTUFBTTtvQkFDTixNQUFNO21CQUNOLE1BQU07eUJBQ04sTUFBTTswQkFDTixNQUFNO3VCQUNOLE1BQU07dUJBQ04sTUFBTTsrQkFDTixNQUFNOzJCQUNOLE1BQU07b0JBQ04sTUFBTTswQkFDTixNQUFNO3dCQVVOLFlBQVksU0FBQyxlQUFlLEVBQUUsQ0FBQyxRQUFRLENBQUM7MEJBV3hDLFlBQVksU0FBQyxpQkFBaUIsRUFBRSxDQUFDLFFBQVEsQ0FBQzs7OztJQTdEM0MsK0JBQWM7O0lBQ2QsaUNBQXNCOztJQUV0Qix3Q0FBc0Y7O0lBQ3RGLHlDQUF3Rjs7SUFDeEYsZ0RBQXNHOztJQUN0Ryw2Q0FBZ0c7O0lBQ2hHLDBDQUFtRjs7SUFpQm5GLHVDQUF5Qjs7SUFDekIsaUNBQW1COztJQUNuQixtQ0FBcUI7O0lBQ3JCLHFDQUF1Qjs7SUFDdkIsdUNBQXlCOztJQUN6QiwrQkFBaUI7O0lBQ2pCLGlDQUFtQjs7SUFDbkIsOEJBQWdCOztJQUNoQiw2QkFBZTs7SUFDZixtQ0FBcUI7O0lBQ3JCLG9DQUFzQjs7SUFDdEIsaUNBQW1COztJQUNuQixpQ0FBbUI7O0lBQ25CLHlDQUEyQjs7SUFDM0IscUNBQXVCOztJQUN2Qiw4QkFBZ0I7O0lBQ2hCLG9DQUFzQjs7SUFHcEIsa0NBQTJCOztJQUMzQiwyQ0FBNkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIENvbnRlbnRDaGlsZCwgRXZlbnRFbWl0dGVyLCBIb3N0TGlzdGVuZXIsIElucHV0LCBPbkNoYW5nZXMsIE91dHB1dCwgVGVtcGxhdGVSZWYsIFZpZXdDaGlsZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBUcmVlTW9kZWwgfSBmcm9tICcuLi9tb2RlbHMvdHJlZS5tb2RlbCc7XHJcbmltcG9ydCB7IFRyZWVEcmFnZ2VkRWxlbWVudCB9IGZyb20gJy4uL21vZGVscy90cmVlLWRyYWdnZWQtZWxlbWVudC5tb2RlbCc7XHJcbmltcG9ydCB7IFRyZWVPcHRpb25zIH0gZnJvbSAnLi4vbW9kZWxzL3RyZWUtb3B0aW9ucy5tb2RlbCc7XHJcbmltcG9ydCB7IElUcmVlT3B0aW9ucyB9IGZyb20gJy4uL2RlZnMvYXBpJztcclxuaW1wb3J0IHsgVHJlZVZpZXdwb3J0Q29tcG9uZW50IH0gZnJvbSAnLi90cmVlLXZpZXdwb3J0LmNvbXBvbmVudCc7XHJcblxyXG5pbXBvcnQgeyBpbmNsdWRlcywgcGljayB9IGZyb20gJ2xvZGFzaC1lcyc7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICBzZWxlY3RvcjogJ1RyZWUsIHRyZWUtcm9vdCcsXHJcbiAgcHJvdmlkZXJzOiBbVHJlZU1vZGVsXSxcclxuICBzdHlsZXM6IFtdLFxyXG4gIHRlbXBsYXRlOiBgXHJcbiAgICAgIDx0cmVlLXZpZXdwb3J0ICN2aWV3cG9ydD5cclxuICAgICAgICAgIDxkaXZcclxuICAgICAgICAgICAgICAgICAgY2xhc3M9XCJhbmd1bGFyLXRyZWUtY29tcG9uZW50XCJcclxuICAgICAgICAgICAgICAgICAgW2NsYXNzLm5vZGUtZHJhZ2dpbmddPVwidHJlZURyYWdnZWRFbGVtZW50LmlzRHJhZ2dpbmcoKVwiXHJcbiAgICAgICAgICAgICAgICAgIFtjbGFzcy5hbmd1bGFyLXRyZWUtY29tcG9uZW50LXJ0bF09XCJ0cmVlTW9kZWwub3B0aW9ucy5ydGxcIj5cclxuICAgICAgICAgICAgICA8dHJlZS1ub2RlLWNvbGxlY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICpuZ0lmPVwidHJlZU1vZGVsLnJvb3RzXCJcclxuICAgICAgICAgICAgICAgICAgICAgIFtub2Rlc109XCJ0cmVlTW9kZWwucm9vdHNcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgW3RyZWVNb2RlbF09XCJ0cmVlTW9kZWxcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgW3RlbXBsYXRlc109XCJ7XHJcbiAgICAgICAgICAgIGxvYWRpbmdUZW1wbGF0ZTogbG9hZGluZ1RlbXBsYXRlLFxyXG4gICAgICAgICAgICB0cmVlTm9kZVRlbXBsYXRlOiB0cmVlTm9kZVRlbXBsYXRlLFxyXG4gICAgICAgICAgICB0cmVlTm9kZVdyYXBwZXJUZW1wbGF0ZTogdHJlZU5vZGVXcmFwcGVyVGVtcGxhdGUsXHJcbiAgICAgICAgICAgIHRyZWVOb2RlRnVsbFRlbXBsYXRlOiB0cmVlTm9kZUZ1bGxUZW1wbGF0ZVxyXG4gICAgICAgICAgfVwiPlxyXG4gICAgICAgICAgICAgIDwvdHJlZS1ub2RlLWNvbGxlY3Rpb24+XHJcbiAgICAgICAgICAgICAgPHRyZWUtbm9kZS1kcm9wLXNsb3RcclxuICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiZW1wdHktdHJlZS1kcm9wLXNsb3RcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgKm5nSWY9XCJ0cmVlTW9kZWwuaXNFbXB0eVRyZWUoKVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICBbZHJvcEluZGV4XT1cIjBcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgW25vZGVdPVwidHJlZU1vZGVsLnZpcnR1YWxSb290XCI+XHJcbiAgICAgICAgICAgICAgPC90cmVlLW5vZGUtZHJvcC1zbG90PlxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgIDwvdHJlZS12aWV3cG9ydD5cclxuICBgXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBUcmVlQ29tcG9uZW50IGltcGxlbWVudHMgT25DaGFuZ2VzIHtcclxuICBfbm9kZXM6IGFueVtdO1xyXG4gIF9vcHRpb25zOiBUcmVlT3B0aW9ucztcclxuXHJcbiAgQENvbnRlbnRDaGlsZCgnbG9hZGluZ1RlbXBsYXRlJywgeyBzdGF0aWM6IGZhbHNlIH0pIGxvYWRpbmdUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcclxuICBAQ29udGVudENoaWxkKCd0cmVlTm9kZVRlbXBsYXRlJywgeyBzdGF0aWM6IGZhbHNlIH0pIHRyZWVOb2RlVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XHJcbiAgQENvbnRlbnRDaGlsZCgndHJlZU5vZGVXcmFwcGVyVGVtcGxhdGUnLCB7IHN0YXRpYzogZmFsc2UgfSkgdHJlZU5vZGVXcmFwcGVyVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XHJcbiAgQENvbnRlbnRDaGlsZCgndHJlZU5vZGVGdWxsVGVtcGxhdGUnLCB7IHN0YXRpYzogZmFsc2UgfSkgdHJlZU5vZGVGdWxsVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XHJcbiAgQFZpZXdDaGlsZCgndmlld3BvcnQnLCB7IHN0YXRpYzogZmFsc2UgfSkgdmlld3BvcnRDb21wb25lbnQ6IFRyZWVWaWV3cG9ydENvbXBvbmVudDtcclxuXHJcbiAgLy8gV2lsbCBiZSBoYW5kbGVkIGluIG5nT25DaGFuZ2VzXHJcbiAgQElucHV0KCkgc2V0IG5vZGVzKG5vZGVzOiBhbnlbXSkge1xyXG4gIH07XHJcblxyXG4gIEBJbnB1dCgpIHNldCBvcHRpb25zKG9wdGlvbnM6IElUcmVlT3B0aW9ucykge1xyXG4gIH07XHJcblxyXG4gIEBJbnB1dCgpIHNldCBmb2N1c2VkKHZhbHVlOiBib29sZWFuKSB7XHJcbiAgICB0aGlzLnRyZWVNb2RlbC5zZXRGb2N1cyh2YWx1ZSk7XHJcbiAgfVxyXG5cclxuICBASW5wdXQoKSBzZXQgc3RhdGUoc3RhdGUpIHtcclxuICAgIHRoaXMudHJlZU1vZGVsLnNldFN0YXRlKHN0YXRlKTtcclxuICB9XHJcblxyXG4gIEBPdXRwdXQoKSB0b2dnbGVFeHBhbmRlZDtcclxuICBAT3V0cHV0KCkgYWN0aXZhdGU7XHJcbiAgQE91dHB1dCgpIGRlYWN0aXZhdGU7XHJcbiAgQE91dHB1dCgpIG5vZGVBY3RpdmF0ZTtcclxuICBAT3V0cHV0KCkgbm9kZURlYWN0aXZhdGU7XHJcbiAgQE91dHB1dCgpIHNlbGVjdDtcclxuICBAT3V0cHV0KCkgZGVzZWxlY3Q7XHJcbiAgQE91dHB1dCgpIGZvY3VzO1xyXG4gIEBPdXRwdXQoKSBibHVyO1xyXG4gIEBPdXRwdXQoKSB1cGRhdGVEYXRhO1xyXG4gIEBPdXRwdXQoKSBpbml0aWFsaXplZDtcclxuICBAT3V0cHV0KCkgbW92ZU5vZGU7XHJcbiAgQE91dHB1dCgpIGNvcHlOb2RlO1xyXG4gIEBPdXRwdXQoKSBsb2FkTm9kZUNoaWxkcmVuO1xyXG4gIEBPdXRwdXQoKSBjaGFuZ2VGaWx0ZXI7XHJcbiAgQE91dHB1dCgpIGV2ZW50O1xyXG4gIEBPdXRwdXQoKSBzdGF0ZUNoYW5nZTtcclxuXHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBwdWJsaWMgdHJlZU1vZGVsOiBUcmVlTW9kZWwsXHJcbiAgICBwdWJsaWMgdHJlZURyYWdnZWRFbGVtZW50OiBUcmVlRHJhZ2dlZEVsZW1lbnQpIHtcclxuXHJcbiAgICB0cmVlTW9kZWwuZXZlbnROYW1lcy5mb3JFYWNoKChuYW1lKSA9PiB0aGlzW25hbWVdID0gbmV3IEV2ZW50RW1pdHRlcigpKTtcclxuICAgIHRyZWVNb2RlbC5zdWJzY3JpYmVUb1N0YXRlKChzdGF0ZSkgPT4gdGhpcy5zdGF0ZUNoYW5nZS5lbWl0KHN0YXRlKSk7XHJcbiAgfVxyXG5cclxuICBASG9zdExpc3RlbmVyKCdib2R5OiBrZXlkb3duJywgWyckZXZlbnQnXSlcclxuICBvbktleWRvd24oJGV2ZW50KSB7XHJcbiAgICBpZiAoIXRoaXMudHJlZU1vZGVsLmlzRm9jdXNlZCkgcmV0dXJuO1xyXG4gICAgaWYgKGluY2x1ZGVzKFsnaW5wdXQnLCAndGV4dGFyZWEnXSxcclxuICAgICAgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkpKSByZXR1cm47XHJcblxyXG4gICAgY29uc3QgZm9jdXNlZE5vZGUgPSB0aGlzLnRyZWVNb2RlbC5nZXRGb2N1c2VkTm9kZSgpO1xyXG5cclxuICAgIHRoaXMudHJlZU1vZGVsLnBlcmZvcm1LZXlBY3Rpb24oZm9jdXNlZE5vZGUsICRldmVudCk7XHJcbiAgfVxyXG5cclxuICBASG9zdExpc3RlbmVyKCdib2R5OiBtb3VzZWRvd24nLCBbJyRldmVudCddKVxyXG4gIG9uTW91c2Vkb3duKCRldmVudCkge1xyXG4gICAgZnVuY3Rpb24gaXNPdXRzaWRlQ2xpY2soc3RhcnRFbGVtZW50OiBFbGVtZW50LCBub2RlTmFtZTogc3RyaW5nKSB7XHJcbiAgICAgIHJldHVybiAhc3RhcnRFbGVtZW50ID8gdHJ1ZSA6IHN0YXJ0RWxlbWVudC5sb2NhbE5hbWUgPT09IG5vZGVOYW1lID8gZmFsc2UgOiBpc091dHNpZGVDbGljayhzdGFydEVsZW1lbnQucGFyZW50RWxlbWVudCwgbm9kZU5hbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc091dHNpZGVDbGljaygkZXZlbnQudGFyZ2V0LCAndHJlZS1yb290JykpIHtcclxuICAgICAgdGhpcy50cmVlTW9kZWwuc2V0Rm9jdXMoZmFsc2UpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xyXG4gICAgaWYgKGNoYW5nZXMub3B0aW9ucyB8fCBjaGFuZ2VzLm5vZGVzKSB7XHJcbiAgICAgIHRoaXMudHJlZU1vZGVsLnNldERhdGEoe1xyXG4gICAgICAgIG9wdGlvbnM6IGNoYW5nZXMub3B0aW9ucyAmJiBjaGFuZ2VzLm9wdGlvbnMuY3VycmVudFZhbHVlLFxyXG4gICAgICAgIG5vZGVzOiBjaGFuZ2VzLm5vZGVzICYmIGNoYW5nZXMubm9kZXMuY3VycmVudFZhbHVlLFxyXG4gICAgICAgIGV2ZW50czogcGljayh0aGlzLCB0aGlzLnRyZWVNb2RlbC5ldmVudE5hbWVzKVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHNpemVDaGFuZ2VkKCkge1xyXG4gICAgdGhpcy52aWV3cG9ydENvbXBvbmVudC5zZXRWaWV3cG9ydCgpO1xyXG4gIH1cclxufVxyXG4iXX0=