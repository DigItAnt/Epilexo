/**
 * @fileoverview added by tsickle
 * Generated from: lib/defs/api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
export function IAllowDropFn() { }
/**
 * @record
 */
export function INodeHeightFn() { }
/**
 * @record
 */
export function IAllowDragFn() { }
/**
 * @record
 */
export function ITreeState() { }
if (false) {
    /** @type {?|undefined} */
    ITreeState.prototype.expandedNodeIds;
    /** @type {?|undefined} */
    ITreeState.prototype.selectedNodeIds;
    /** @type {?|undefined} */
    ITreeState.prototype.activeNodeIds;
    /** @type {?|undefined} */
    ITreeState.prototype.hiddenNodeIds;
    /** @type {?|undefined} */
    ITreeState.prototype.selectedLeafNodeIds;
    /** @type {?|undefined} */
    ITreeState.prototype.focusedNodeId;
}
/**
 * @record
 */
export function ITreeOptions() { }
if (false) {
    /**
     * A string representing the attribute of the node that indicates whether there are child nodes.
     * **Default value: `hasChildren`.**
     * For example, if your nodes have an `isDirectory` attribute that indicates whether there are children, use:
     * ```
     * options = { hasChildrenField: 'isDirectory' }
     * ```
     * @type {?|undefined}
     */
    ITreeOptions.prototype.hasChildrenField;
    /**
     * A string representing the attribute of the node that contains the array of children.
     * **Default value: `children`.**
     * For example, if your nodes have a `nodes` attribute, that contains the children, use:
     * ```
     * options = { childrenField: 'nodes' }
     * ```
     * @type {?|undefined}
     */
    ITreeOptions.prototype.childrenField;
    /**
     * A string representing the attribute of the node to display.
     * **Default value: `name`**
     * For example, if your nodes have a `title` attribute that should be displayed, use:
     * ```
     * options = { displayField: 'title' }
     * ```
     * @type {?|undefined}
     */
    ITreeOptions.prototype.displayField;
    /**
     * A string representing the attribute of the node that contains the unique ID.
     * This will be used to construct the `path`, which is an array of IDs that point to the node.
     * **Default value: `id`.**
     * For example, if your nodes have a `uuid` attribute, that contains the unique key, use:
     * ```
     * options = { idField: 'uuid' }
     * ```
     * @type {?|undefined}
     */
    ITreeOptions.prototype.idField;
    /**
     * A string representing the attribute of the node that contains whether the node starts as expanded.
     * **Default value: `isExpanded`.**
     * For example, if your nodes have an `expanded` attribute, that contains a boolean value, use:
     * ```
     * options = { isExpandedField: 'expanded' }
     * ```
     * @type {?|undefined}
     */
    ITreeOptions.prototype.isExpandedField;
    /**
     * Function for loading a node's children.
     * The function receives a TreeNode, and returns a value or a promise that resolves to the node's children.
     * This function will be called whenever a node is expanded, the `hasChildren` (`options.hasChildrenField`)
     * field is true, and the `children` field is empty.
     * The result will be loaded into the node's children attribute.
     * Example:
     * ```
     * options = {
     *   getChildren: (node:TreeNode) => {
     *     return request('/api/children/' + node.id);
     *   }
     * }
     * ```
     * @type {?|undefined}
     */
    ITreeOptions.prototype.getChildren;
    /**
     * Rewire which trigger causes which action using this attribute, or create custom actions / event bindings.
     * See the [Action Mapping Section](https://angular2-tree.readme.io/docs/action-mapping) for more details.
     * @type {?|undefined}
     */
    ITreeOptions.prototype.actionMapping;
    /**
     * Specify if dragging tree nodes is allowed.
     * This could be a boolean, or a function that receives a TreeNode and returns a boolean
     * **Default value: false**
     * Example:
     * ```
     * options = {
     *  allowDrag: true
     * }
     * ```
     * @type {?|undefined}
     */
    ITreeOptions.prototype.allowDrag;
    /**
     * Specify whether dropping inside the tree is allowed. Optional types:
     *  - boolean
     *  - (element:any, to:{parent:TreeNode, index:number}):boolean
     * A function that receives the dragged element, and the drop location (parent node and index inside the parent),
     * and returns true or false.
     * **Default Value: true**
     * example:
     * ```
     * options = {
     *  allowDrop: (element, {parent, index}) => parent.isLeaf
     * }
     * ```
     * @type {?|undefined}
     */
    ITreeOptions.prototype.allowDrop;
    /**
     * Boolean flag to allow adding and removing is-dragging-over and is-dragging-over-disabled classes.
     * If set to false it will not add the above mentioned classes and you should handle the styling yourself with css and in
     * the actionMapping -> mouse -> dragEnter, dragLeave
     * **Default Value: true**
     * example:
     * ```
     * options = {
     *   allowDrop: true,
     *   allowDragoverStyling: false
     * }
     * ```
     * @type {?|undefined}
     */
    ITreeOptions.prototype.allowDragoverStyling;
    /**
     * Specify padding per node (integer).
     * Each node will have padding-left value of level * levelPadding, instead of using the default padding for children.
     * This option is good for example for allowing whole row selection, etc.
     * You can alternatively use the tree-node-level-X classes to give padding on a per-level basis.
     * **Default value: 0**
     * @type {?|undefined}
     */
    ITreeOptions.prototype.levelPadding;
    /**
     * Specify a function that returns a class per node. Useful for styling the nodes individually.
     * Example:
     * ```
     * options = {
     *   nodeClass: (node:TreeNode) => {
     *     return 'icon-' + node.data.icon;
     *   }
     * }
     * ```
     * @type {?|undefined}
     */
    ITreeOptions.prototype.nodeClass;
    /**
     * Boolean flag to use the virtual scroll option.
     * To use this option, you must supply the height of the container, and the height of each node in the tree.
     * You can also specify height for the dropSlot which is located between nodes.
     * **Default Value: false**
     * example:
     * ```
     * options = {
     *   useVirtualScroll: true,
     *   nodeHeight: (node: TreeNode) => node.myHeight,
     *   dropSlotHeight: 3
     * }
     * ```
     * @type {?|undefined}
     */
    ITreeOptions.prototype.useVirtualScroll;
    /**
     * For use with `useVirtualScroll` option.
     * Specify a height for nodes in pixels. Could be either:
     * - number
     * - (node: TreeNode) => number
     * **Default Value: 22**
     * @type {?|undefined}
     */
    ITreeOptions.prototype.nodeHeight;
    /**
     * For use with `useVirtualScroll` option.
     * Specify a height for drop slots (located between nodes) in pixels
     * **Default Value: 2**
     * @type {?|undefined}
     */
    ITreeOptions.prototype.dropSlotHeight;
    /**
     * Boolean whether or not to animate expand / collapse of nodes.
     * **Default Value: false**
     * @type {?|undefined}
     */
    ITreeOptions.prototype.animateExpand;
    /**
     * Speed of expand animation (described in pixels per 17 ms).
     * **Default Value: 30**
     * @type {?|undefined}
     */
    ITreeOptions.prototype.animateSpeed;
    /**
     * Increase of expand animation speed (described in multiply per 17 ms).
     * **Default Value: 1.2**
     * @type {?|undefined}
     */
    ITreeOptions.prototype.animateAcceleration;
    /**
     * Whether to scroll to the node to make it visible when it is activated.
     * **Default Value: true**
     * @type {?|undefined}
     */
    ITreeOptions.prototype.scrollOnActivate;
    /**
     * Function to clone a node.
     * Receives a TreeNode object, and returns a node object (only the data).
     * This callback will be called when copying a node inside the tree,
     * by either calling copyNode, or by dragging and holding the ctrl key
     *
     * For example:
     * ```
     * options: ITreeOptions = {
     * getNodeClone: (node) => ({
     * ...node.data,
     * id: uuid.v4(),
     * name: `copy of ${node.data.name}`
     * })
     * };
     * ```
     *
     * **Default Value: clone the node using Object.assign, and remove 'id' property**
     * @type {?|undefined}
     */
    ITreeOptions.prototype.getNodeClone;
    /**
     * Makes the tree right-to-left.
     * This include direction, expander style, and change key binding (right key collapse and left key expands instead of vice-versa)
     * @type {?|undefined}
     */
    ITreeOptions.prototype.rtl;
    /**
     * Specifies id of root node (virtualRoot)
     * @type {?|undefined}
     */
    ITreeOptions.prototype.rootId;
    /**
     * Whether to display a checkbox next to the node or not
     * @type {?|undefined}
     */
    ITreeOptions.prototype.useCheckbox;
    /**
     * Whether to use master checkboxes mechanism if the useCheckbox is set to true
     * @type {?|undefined}
     */
    ITreeOptions.prototype.useTriState;
    /**
     * The HTML element that is the scroll container for the tree.
     * The default behaviour is to wrap the tree with a container that has overflow: hidden,
     * and then the scrolling container is the viewport inside the tree component
     * @type {?|undefined}
     */
    ITreeOptions.prototype.scrollContainer;
}
/**
 * @record
 */
export function ITreeNode() { }
if (false) {
    /**
     * Parent node
     * @type {?}
     */
    ITreeNode.prototype.parent;
    /**
     * The value of the node's field that is used for displaying its content.
     * By default 'name', unless stated otherwise in the options
     * @type {?}
     */
    ITreeNode.prototype.displayField;
    /**
     * The children of the node.
     * By default is determined by 'node.data.children', unless stated otherwise in the options
     * @type {?}
     */
    ITreeNode.prototype.children;
    /**
     * Pointer to the original data.
     * @type {?}
     */
    ITreeNode.prototype.data;
    /**
     * Pointer to the ElementRef of the TreeNodeComponent that's displaying this node
     * @type {?}
     */
    ITreeNode.prototype.elementRef;
    /**
     * Level in the tree (starts from 1).
     * @type {?}
     */
    ITreeNode.prototype.level;
    /**
     * Path in the tree: Array of IDs.
     * @type {?}
     */
    ITreeNode.prototype.path;
    /**
     * index of the node inside its parent's children
     * @type {?}
     */
    ITreeNode.prototype.index;
    /**
     * A unique key of this node among its siblings.
     * By default it's the 'id' of the original node, unless stated otherwise in options.idField
     * @type {?}
     */
    ITreeNode.prototype.id;
    /** @type {?} */
    ITreeNode.prototype.isExpanded;
    /** @type {?} */
    ITreeNode.prototype.isActive;
    /** @type {?} */
    ITreeNode.prototype.isFocused;
    /** @type {?} */
    ITreeNode.prototype.isCollapsed;
    /** @type {?} */
    ITreeNode.prototype.isLeaf;
    /** @type {?} */
    ITreeNode.prototype.hasChildren;
    /** @type {?} */
    ITreeNode.prototype.isRoot;
    /**
     * @param {?} skipHidden whether to skip hidden nodes
     * @return {?} next sibling (or null)
     */
    ITreeNode.prototype.findNextSibling = function (skipHidden) { };
    /**
     * @param {?} skipHidden whether to skip hidden nodes
     * @return {?} previous sibling (or null)
     */
    ITreeNode.prototype.findPreviousSibling = function (skipHidden) { };
    /**
     * @param {?} skipHidden whether to skip hidden nodes
     * @return {?} first child (or null)
     */
    ITreeNode.prototype.getFirstChild = function (skipHidden) { };
    /**
     * @param {?} skipHidden whether to skip hidden nodes
     * @return {?} last child (or null)
     */
    ITreeNode.prototype.getLastChild = function (skipHidden) { };
    /**
     * Finds the visually next node in the tree.
     * @param {?} goInside whether to look for children or just siblings
     * @return {?} next node.
     */
    ITreeNode.prototype.findNextNode = function (goInside) { };
    /**
     * Finds the visually previous node in the tree.
     * @param {?} skipHidden whether to skip hidden nodes
     * @return {?} previous node.
     */
    ITreeNode.prototype.findPreviousNode = function (skipHidden) { };
    /**
     * @param {?} node
     * @return {?} true if this node is a descendant of the parameter node
     */
    ITreeNode.prototype.isDescendantOf = function (node) { };
    /**
     * @return {?} in case levelPadding option is supplied, returns the current node's padding
     */
    ITreeNode.prototype.getNodePadding = function () { };
    /**
     * @return {?} in case nodeClass option is supplied, returns the current node's class
     */
    ITreeNode.prototype.getClass = function () { };
    /**
     * Expands / Collapses the node
     * @return {?}
     */
    ITreeNode.prototype.toggleExpanded = function () { };
    /**
     * Expands the node
     * @return {?}
     */
    ITreeNode.prototype.expand = function () { };
    /**
     * Collapses the node
     * @return {?}
     */
    ITreeNode.prototype.collapse = function () { };
    /**
     * Expands all ancestors of the node
     * @return {?}
     */
    ITreeNode.prototype.ensureVisible = function () { };
    /**
     * Activates / Deactivates the node (selects / deselects)
     * @param {?} multi
     * @return {?}
     */
    ITreeNode.prototype.toggleActivated = function (multi) { };
    /**
     * Focus on the node
     * @return {?}
     */
    ITreeNode.prototype.focus = function () { };
    /**
     * Blur (unfocus) the node
     * @return {?}
     */
    ITreeNode.prototype.blur = function () { };
    /**
     * Hides the node
     * @return {?}
     */
    ITreeNode.prototype.hide = function () { };
    /**
     * Makes the node visible
     * @return {?}
     */
    ITreeNode.prototype.show = function () { };
    /**
     * @param {?} value  if true makes the node hidden, otherwise visible
     * @return {?}
     */
    ITreeNode.prototype.setIsHidden = function (value) { };
    /**
     * Scroll the screen to make the node visible
     * @return {?}
     */
    ITreeNode.prototype.scrollIntoView = function () { };
    /**
     * Fire an event to the renderer of the tree (if it was registered)
     * @param {?} event
     * @return {?}
     */
    ITreeNode.prototype.fireEvent = function (event) { };
    /**
     * Invokes a method for every node under this one - depth first
     * @param {?} fn  a function that receives the node
     * @return {?}
     */
    ITreeNode.prototype.doForAll = function (fn) { };
    /**
     * expand all nodes under this one
     * @return {?}
     */
    ITreeNode.prototype.expandAll = function () { };
    /**
     * collapse all nodes under this one
     * @return {?}
     */
    ITreeNode.prototype.collapseAll = function () { };
    /**
     * sets the node to active / inactive according to the value.
     * If multi is true (default false) - does a multiselect.
     * @param {?} value
     * @param {?=} multi
     * @return {?}
     */
    ITreeNode.prototype.setIsActive = function (value, multi) { };
    /**
     * sets the node to be active and makes sure it's visible by expanding all nodes above it and scrolling it into view.
     * Very similar to calling `activate`, `ensureVisible` and `scrollIntoView` methods.
     * If multi is true (default false) - does a multiselect.
     * @param {?} multi
     * @return {?}
     */
    ITreeNode.prototype.setActiveAndVisible = function (multi) { };
}
/**
 * @record
 */
export function ITreeModel() { }
if (false) {
    /**
     * All root nodes
     * @type {?}
     */
    ITreeModel.prototype.roots;
    /**
     * Current focused node
     * @type {?}
     */
    ITreeModel.prototype.focusedNode;
    /**
     * Options that were passed to the tree component
     * @type {?}
     */
    ITreeModel.prototype.options;
    /**
     * Is the tree currently focused
     * @type {?}
     */
    ITreeModel.prototype.isFocused;
    /**
     * \@return Current active nodes
     * @type {?}
     */
    ITreeModel.prototype.activeNodes;
    /**
     * \@return Current expanded nodes
     * @type {?}
     */
    ITreeModel.prototype.expandedNodes;
    /**
     * @return {?} Current active node. If multiple nodes are active - returns the first one.
     */
    ITreeModel.prototype.getActiveNode = function () { };
    /**
     * @return {?} Current focused node (either hovered or traversed with keys)
     */
    ITreeModel.prototype.getFocusedNode = function () { };
    /**
     * Set focus on a node
     * @param {?} node
     * @return {?}
     */
    ITreeModel.prototype.setFocusedNode = function (node) { };
    /**
     * @param {?=} skipHidden  true or false - whether to skip hidden nodes
     * @return {?} first root of the tree
     */
    ITreeModel.prototype.getFirstRoot = function (skipHidden) { };
    /**
     * @param {?=} skipHidden  true or false - whether to skip hidden nodes
     * @return {?} last root of the tree
     */
    ITreeModel.prototype.getLastRoot = function (skipHidden) { };
    /**
     * @return {?} true if the tree is empty
     */
    ITreeModel.prototype.isEmptyTree = function () { };
    /**
     * @return {?} All root nodes that pass the current filter
     */
    ITreeModel.prototype.getVisibleRoots = function () { };
    /**
     * @param {?} path  array of node IDs to be traversed respectively
     * @param {?=} startNode
     * @return {?} The node, if found - null otherwise
     */
    ITreeModel.prototype.getNodeByPath = function (path, startNode) { };
    /**
     * @param {?} id  node ID to find
     * @return {?} The node, if found - null otherwise
     */
    ITreeModel.prototype.getNodeById = function (id) { };
    /**
     * @param {?} predicate - either an object or a function, used as a test condition on all nodes.
     *            Could be every predicate that's supported by lodash's `find` method
     * @param {?=} startNode
     * @return {?} First node that matches the predicate, if found - null otherwise
     */
    ITreeModel.prototype.getNodeBy = function (predicate, startNode) { };
    /**
     * get tree state
     * @return {?}
     */
    ITreeModel.prototype.getState = function () { };
    /**
     * Focuses or blurs the tree
     * @param {?} value  true or false - whether to set focus or blur.
     * @return {?}
     */
    ITreeModel.prototype.setFocus = function (value) { };
    /**
     * Focuses on the next node in the tree (same as down arrow)
     * @return {?}
     */
    ITreeModel.prototype.focusNextNode = function () { };
    /**
     * Focuses on the previous node in the tree (same as up arrow)
     * @return {?}
     */
    ITreeModel.prototype.focusPreviousNode = function () { };
    /**
     * Focuses on the inner child of the current focused node (same as right arrow on an expanded node)
     * @return {?}
     */
    ITreeModel.prototype.focusDrillDown = function () { };
    /**
     * Focuses on the parent of the current focused node (same as left arrow on a collapsed node)
     * @return {?}
     */
    ITreeModel.prototype.focusDrillUp = function () { };
    /**
     * Marks isHidden field in all nodes recursively according to the filter param.
     * If a node is marked visible, all of its ancestors will be marked visible as well.
     * @param {?} filter  either a string or a function.
     *   In case it's a string, it will be searched case insensitively in the node's display attribute
     *   In case it's a function, it will be passed the node, and should return true if the node should be visible, false otherwise
     * @param {?=} autoShow  if true, make sure all nodes that passed the filter are visible
     * @return {?}
     */
    ITreeModel.prototype.filterNodes = function (filter, autoShow) { };
    /**
     * Marks all nodes isHidden = false
     * @return {?}
     */
    ITreeModel.prototype.clearFilter = function () { };
    /**
     * moves a node from one location in the tree to another
     * @param {?} node describes which node needs to be moved
     * @param {?} to describes where to move the node to.
     * @param {?} from describes where to move the node from.
     * Contains a 'parent' node, an 'index', and a 'dropOnNode' - to distinguish between dropping between nodes or on the node
     * @return {?}
     */
    ITreeModel.prototype.moveNode = function (node, to, from) { };
    /**
     * Invokes a method for every node of the tree - depth first
     * @param {?} fn  a function that receives the node
     * @return {?}
     */
    ITreeModel.prototype.doForAll = function (fn) { };
    /**
     * expand all nodes
     * @return {?}
     */
    ITreeModel.prototype.expandAll = function () { };
    /**
     * collapse all nodes
     * @return {?}
     */
    ITreeModel.prototype.collapseAll = function () { };
    /**
     * set tree state
     * @param {?} state
     * @return {?}
     */
    ITreeModel.prototype.setState = function (state) { };
    /**
     * @param {?} fn
     * @return {?}
     */
    ITreeModel.prototype.subscribeToState = function (fn) { };
}
/**
 * This is the interface of the TreeNodeDrag service
 * @record
 */
export function ITreeNodeDrag() { }
if (false) {
    /**
     * Gets the current dragged node. Useful for overriding the drop action.
     * @return {?}
     */
    ITreeNodeDrag.prototype.getDragNode = function () { };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXBpLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvYW5ndWxhci10cmVlLWNvbXBvbmVudC9zcmMvbGliL2RlZnMvYXBpLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBV0Esa0NBRUM7Ozs7QUFFRCxtQ0FFQzs7OztBQUVELGtDQUVDOzs7O0FBR0QsZ0NBT0M7OztJQU5DLHFDQUFtQzs7SUFDbkMscUNBQW1DOztJQUNuQyxtQ0FBaUM7O0lBQ2pDLG1DQUFpQzs7SUFDakMseUNBQXVDOztJQUN2QyxtQ0FBdUI7Ozs7O0FBR3pCLGtDQThQRTs7Ozs7Ozs7Ozs7SUFuUEMsd0NBQTBCOzs7Ozs7Ozs7O0lBVzFCLHFDQUF1Qjs7Ozs7Ozs7OztJQVd2QixvQ0FBc0I7Ozs7Ozs7Ozs7O0lBWXRCLCtCQUFpQjs7Ozs7Ozs7OztJQVdqQix1Q0FBeUI7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBa0J6QixtQ0FBc0M7Ozs7OztJQUt0QyxxQ0FBb0I7Ozs7Ozs7Ozs7Ozs7SUFjcEIsaUNBQW1DOzs7Ozs7Ozs7Ozs7Ozs7O0lBaUJuQyxpQ0FBbUM7Ozs7Ozs7Ozs7Ozs7OztJQWlCbkMsNENBQStCOzs7Ozs7Ozs7SUFXL0Isb0NBQXNCOzs7Ozs7Ozs7Ozs7O0lBYXRCLGlDQUF1Qzs7Ozs7Ozs7Ozs7Ozs7OztJQW1CdkMsd0NBQTJCOzs7Ozs7Ozs7SUFTM0Isa0NBQW9DOzs7Ozs7O0lBT3BDLHNDQUF3Qjs7Ozs7O0lBTXhCLHFDQUF3Qjs7Ozs7O0lBTXhCLG9DQUFzQjs7Ozs7O0lBTXRCLDJDQUE2Qjs7Ozs7O0lBTTdCLHdDQUEyQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBb0IxQixvQ0FBdUM7Ozs7OztJQUt2QywyQkFBYzs7Ozs7SUFJZCw4QkFBYTs7Ozs7SUFJYixtQ0FBc0I7Ozs7O0lBSXRCLG1DQUFzQjs7Ozs7OztJQU10Qix1Q0FBOEI7Ozs7O0FBR2xDLCtCQTZLQzs7Ozs7O0lBeEtDLDJCQUFrQjs7Ozs7O0lBS2xCLGlDQUFxQjs7Ozs7O0lBS3JCLDZCQUFzQjs7Ozs7SUFJdEIseUJBQVU7Ozs7O0lBSVYsK0JBQWdCOzs7OztJQUloQiwwQkFBYzs7Ozs7SUFJZCx5QkFBZTs7Ozs7SUFJZiwwQkFBYzs7Ozs7O0lBS2QsdUJBQVc7O0lBR1gsK0JBQW9COztJQUNwQiw2QkFBa0I7O0lBQ2xCLDhCQUFtQjs7SUFDbkIsZ0NBQXFCOztJQUNyQiwyQkFBZ0I7O0lBQ2hCLGdDQUFxQjs7SUFDckIsMkJBQWdCOzs7OztJQU9oQixnRUFBdUM7Ozs7O0lBS3ZDLG9FQUEyQzs7Ozs7SUFLM0MsOERBQXFDOzs7OztJQUtyQyw2REFBb0M7Ozs7OztJQU1wQywyREFBMkM7Ozs7OztJQU0zQyxpRUFBd0M7Ozs7O0lBS3hDLHlEQUF5Qzs7OztJQUt6QyxxREFBeUI7Ozs7SUFLekIsK0NBQW1COzs7OztJQU1uQixxREFBaUI7Ozs7O0lBSWpCLDZDQUFTOzs7OztJQUlULCtDQUFXOzs7OztJQUlYLG9EQUFnQjs7Ozs7O0lBSWhCLDJEQUF1Qjs7Ozs7SUFJdkIsNENBQVE7Ozs7O0lBSVIsMkNBQU87Ozs7O0lBSVAsMkNBQU87Ozs7O0lBSVAsMkNBQU87Ozs7O0lBSVAsdURBQTRCOzs7OztJQUk1QixxREFBaUI7Ozs7OztJQUlqQixxREFBc0I7Ozs7OztJQUt0QixpREFBdUM7Ozs7O0lBSXZDLGdEQUFZOzs7OztJQUlaLGtEQUFjOzs7Ozs7OztJQUtkLDhEQUE2Qzs7Ozs7Ozs7SUFNN0MsK0RBQW9DOzs7OztBQUd0QyxnQ0FpSkM7Ozs7OztJQTVJQywyQkFBbUI7Ozs7O0lBSW5CLGlDQUF1Qjs7Ozs7SUFJdkIsNkJBQXNCOzs7OztJQUt0QiwrQkFBbUI7Ozs7O0lBSW5CLGlDQUF5Qjs7Ozs7SUFJekIsbUNBQTJCOzs7O0lBTTNCLHFEQUEyQjs7OztJQUkzQixzREFBNEI7Ozs7OztJQUs1QiwwREFBZ0M7Ozs7O0lBS2hDLDhEQUE4Qzs7Ozs7SUFLOUMsNkRBQTZDOzs7O0lBSTdDLG1EQUF1Qjs7OztJQUl2Qix1REFBK0I7Ozs7OztJQU0vQixvRUFBNkQ7Ozs7O0lBSzdELHFEQUFtQzs7Ozs7OztJQU9uQyxxRUFBNEQ7Ozs7O0lBSTVELGdEQUF1Qjs7Ozs7O0lBT3ZCLHFEQUF5Qjs7Ozs7SUFJekIscURBQWdCOzs7OztJQUloQix5REFBb0I7Ozs7O0lBSXBCLHNEQUFpQjs7Ozs7SUFJakIsb0RBQWU7Ozs7Ozs7Ozs7SUFTZixtRUFBd0M7Ozs7O0lBSXhDLG1EQUFjOzs7Ozs7Ozs7SUFRZCw4REFBaUk7Ozs7OztJQUtqSSxrREFBdUM7Ozs7O0lBSXZDLGlEQUFZOzs7OztJQUlaLG1EQUFjOzs7Ozs7SUFJZCxxREFBNEI7Ozs7O0lBRTVCLDBEQUFpRDs7Ozs7O0FBS25ELG1DQU9DOzs7Ozs7SUFEQyxzREFBaUQiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogV2VsY29tZSB0byBuZzJ0cmVlXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBJRFR5cGUgPSBzdHJpbmcgfCBudW1iZXI7XHJcbmV4cG9ydCB0eXBlIElEVHlwZURpY3Rpb25hcnkgPSB7IFtpZDogc3RyaW5nXTogYm9vbGVhbiwgW2lkOiBudW1iZXJdOiBib29sZWFuIH07XHJcblxyXG4vKipcclxuICogU2VlIElUcmVlTm9kZSBmb3IgZG9jdW1lbnRhdGlvblxyXG4gKi9cclxuZXhwb3J0IGRlY2xhcmUgdHlwZSBUcmVlTm9kZSA9IGFueTtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUFsbG93RHJvcEZuIHtcclxuICAoZWxlbWVudDogYW55LCB0bzoge3BhcmVudDogVHJlZU5vZGUsIGluZGV4OiBudW1iZXJ9LCAkZXZlbnQ/OiBhbnkpOiBib29sZWFuO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElOb2RlSGVpZ2h0Rm4ge1xyXG4gIChub2RlOiBUcmVlTm9kZSk6IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBJQWxsb3dEcmFnRm4ge1xyXG4gIChub2RlOiBUcmVlTm9kZSk6IGJvb2xlYW47XHJcbn1cclxuXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElUcmVlU3RhdGUge1xyXG4gIGV4cGFuZGVkTm9kZUlkcz86IElEVHlwZURpY3Rpb25hcnk7XHJcbiAgc2VsZWN0ZWROb2RlSWRzPzogSURUeXBlRGljdGlvbmFyeTtcclxuICBhY3RpdmVOb2RlSWRzPzogSURUeXBlRGljdGlvbmFyeTtcclxuICBoaWRkZW5Ob2RlSWRzPzogSURUeXBlRGljdGlvbmFyeTtcclxuICBzZWxlY3RlZExlYWZOb2RlSWRzPzogSURUeXBlRGljdGlvbmFyeTtcclxuICBmb2N1c2VkTm9kZUlkPzogSURUeXBlO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElUcmVlT3B0aW9ucyB7XHJcbiAgIC8qKlxyXG4gICAgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGF0dHJpYnV0ZSBvZiB0aGUgbm9kZSB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHRoZXJlIGFyZSBjaGlsZCBub2Rlcy5cclxuXHJcbiAgICAqICoqRGVmYXVsdCB2YWx1ZTogYGhhc0NoaWxkcmVuYC4qKlxyXG5cclxuICAgIEZvciBleGFtcGxlLCBpZiB5b3VyIG5vZGVzIGhhdmUgYW4gYGlzRGlyZWN0b3J5YCBhdHRyaWJ1dGUgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB0aGVyZSBhcmUgY2hpbGRyZW4sIHVzZTpcclxuICAgIGBgYFxyXG4gICAgICBvcHRpb25zID0geyBoYXNDaGlsZHJlbkZpZWxkOiAnaXNEaXJlY3RvcnknIH1cclxuICAgIGBgYFxyXG4gICAgKi9cclxuICAgaGFzQ2hpbGRyZW5GaWVsZD86IHN0cmluZztcclxuICAgLyoqXHJcbiAgICAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgYXR0cmlidXRlIG9mIHRoZSBub2RlIHRoYXQgY29udGFpbnMgdGhlIGFycmF5IG9mIGNoaWxkcmVuLlxyXG5cclxuICAgICogKipEZWZhdWx0IHZhbHVlOiBgY2hpbGRyZW5gLioqXHJcblxyXG4gICAgRm9yIGV4YW1wbGUsIGlmIHlvdXIgbm9kZXMgaGF2ZSBhIGBub2Rlc2AgYXR0cmlidXRlLCB0aGF0IGNvbnRhaW5zIHRoZSBjaGlsZHJlbiwgdXNlOlxyXG4gICAgYGBgXHJcbiAgICAgIG9wdGlvbnMgPSB7IGNoaWxkcmVuRmllbGQ6ICdub2RlcycgfVxyXG4gICAgYGBgXHJcbiAgICAqL1xyXG4gICBjaGlsZHJlbkZpZWxkPzogc3RyaW5nO1xyXG4gICAvKipcclxuICAgICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBhdHRyaWJ1dGUgb2YgdGhlIG5vZGUgdG8gZGlzcGxheS5cclxuXHJcbiAgICAqICoqRGVmYXVsdCB2YWx1ZTogYG5hbWVgKipcclxuXHJcbiAgICAgIEZvciBleGFtcGxlLCBpZiB5b3VyIG5vZGVzIGhhdmUgYSBgdGl0bGVgIGF0dHJpYnV0ZSB0aGF0IHNob3VsZCBiZSBkaXNwbGF5ZWQsIHVzZTpcclxuICAgICAgYGBgXHJcbiAgICAgICAgb3B0aW9ucyA9IHsgZGlzcGxheUZpZWxkOiAndGl0bGUnIH1cclxuICAgICAgYGBgXHJcbiAgICAqL1xyXG4gICBkaXNwbGF5RmllbGQ/OiBzdHJpbmc7XHJcbiAgIC8qKlxyXG4gICAgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGF0dHJpYnV0ZSBvZiB0aGUgbm9kZSB0aGF0IGNvbnRhaW5zIHRoZSB1bmlxdWUgSUQuXHJcbiAgICAgIFRoaXMgd2lsbCBiZSB1c2VkIHRvIGNvbnN0cnVjdCB0aGUgYHBhdGhgLCB3aGljaCBpcyBhbiBhcnJheSBvZiBJRHMgdGhhdCBwb2ludCB0byB0aGUgbm9kZS5cclxuXHJcbiAgICAgICogKipEZWZhdWx0IHZhbHVlOiBgaWRgLioqXHJcblxyXG4gICAgICBGb3IgZXhhbXBsZSwgaWYgeW91ciBub2RlcyBoYXZlIGEgYHV1aWRgIGF0dHJpYnV0ZSwgdGhhdCBjb250YWlucyB0aGUgdW5pcXVlIGtleSwgdXNlOlxyXG4gICAgICBgYGBcclxuICAgICAgICBvcHRpb25zID0geyBpZEZpZWxkOiAndXVpZCcgfVxyXG4gICAgICBgYGBcclxuICAgICovXHJcbiAgIGlkRmllbGQ/OiBzdHJpbmc7XHJcbiAgIC8qKlxyXG4gICAgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGF0dHJpYnV0ZSBvZiB0aGUgbm9kZSB0aGF0IGNvbnRhaW5zIHdoZXRoZXIgdGhlIG5vZGUgc3RhcnRzIGFzIGV4cGFuZGVkLlxyXG5cclxuICAgICAgKiAqKkRlZmF1bHQgdmFsdWU6IGBpc0V4cGFuZGVkYC4qKlxyXG5cclxuICAgICAgRm9yIGV4YW1wbGUsIGlmIHlvdXIgbm9kZXMgaGF2ZSBhbiBgZXhwYW5kZWRgIGF0dHJpYnV0ZSwgdGhhdCBjb250YWlucyBhIGJvb2xlYW4gdmFsdWUsIHVzZTpcclxuICAgICAgYGBgXHJcbiAgICAgICAgb3B0aW9ucyA9IHsgaXNFeHBhbmRlZEZpZWxkOiAnZXhwYW5kZWQnIH1cclxuICAgICAgYGBgXHJcbiAgICAqL1xyXG4gICBpc0V4cGFuZGVkRmllbGQ/OiBzdHJpbmc7XHJcbiAgIC8qKlxyXG4gICAgKiBGdW5jdGlvbiBmb3IgbG9hZGluZyBhIG5vZGUncyBjaGlsZHJlbi5cclxuICAgICAgVGhlIGZ1bmN0aW9uIHJlY2VpdmVzIGEgVHJlZU5vZGUsIGFuZCByZXR1cm5zIGEgdmFsdWUgb3IgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIG5vZGUncyBjaGlsZHJlbi5cclxuXHJcbiAgICAgIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXIgYSBub2RlIGlzIGV4cGFuZGVkLCB0aGUgYGhhc0NoaWxkcmVuYCAoYG9wdGlvbnMuaGFzQ2hpbGRyZW5GaWVsZGApXHJcbiAgICAgIGZpZWxkIGlzIHRydWUsIGFuZCB0aGUgYGNoaWxkcmVuYCBmaWVsZCBpcyBlbXB0eS5cclxuICAgICAgVGhlIHJlc3VsdCB3aWxsIGJlIGxvYWRlZCBpbnRvIHRoZSBub2RlJ3MgY2hpbGRyZW4gYXR0cmlidXRlLlxyXG5cclxuICAgICAgRXhhbXBsZTpcclxuICAgICAgYGBgXHJcbiAgICAgICogb3B0aW9ucyA9IHtcclxuICAgICAgKiAgIGdldENoaWxkcmVuOiAobm9kZTpUcmVlTm9kZSkgPT4ge1xyXG4gICAgICAqICAgICByZXR1cm4gcmVxdWVzdCgnL2FwaS9jaGlsZHJlbi8nICsgbm9kZS5pZCk7XHJcbiAgICAgICogICB9XHJcbiAgICAgICogfVxyXG4gICAgICBgYGBcclxuICAgICovXHJcbiAgIGdldENoaWxkcmVuPzogKG5vZGU6IFRyZWVOb2RlKSA9PiBhbnk7XHJcbiAgIC8qKlxyXG4gICAgKiBSZXdpcmUgd2hpY2ggdHJpZ2dlciBjYXVzZXMgd2hpY2ggYWN0aW9uIHVzaW5nIHRoaXMgYXR0cmlidXRlLCBvciBjcmVhdGUgY3VzdG9tIGFjdGlvbnMgLyBldmVudCBiaW5kaW5ncy5cclxuICAgICogU2VlIHRoZSBbQWN0aW9uIE1hcHBpbmcgU2VjdGlvbl0oaHR0cHM6Ly9hbmd1bGFyMi10cmVlLnJlYWRtZS5pby9kb2NzL2FjdGlvbi1tYXBwaW5nKSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gICAgKi9cclxuICAgYWN0aW9uTWFwcGluZz86IGFueTtcclxuICAgLyoqXHJcbiAgICAqIFNwZWNpZnkgaWYgZHJhZ2dpbmcgdHJlZSBub2RlcyBpcyBhbGxvd2VkLlxyXG4gICAgKiBUaGlzIGNvdWxkIGJlIGEgYm9vbGVhbiwgb3IgYSBmdW5jdGlvbiB0aGF0IHJlY2VpdmVzIGEgVHJlZU5vZGUgYW5kIHJldHVybnMgYSBib29sZWFuXHJcblxyXG4gICAgKiAqKkRlZmF1bHQgdmFsdWU6IGZhbHNlKipcclxuXHJcbiAgICBFeGFtcGxlOlxyXG4gICAgYGBgXHJcbiAgICAqIG9wdGlvbnMgPSB7XHJcbiAgICAqICBhbGxvd0RyYWc6IHRydWVcclxuICAgICogfVxyXG4gICAgYGBgXHJcbiAgICAqL1xyXG4gICBhbGxvd0RyYWc/OiBib29sZWFuIHwgSUFsbG93RHJhZ0ZuO1xyXG4gICAvKipcclxuICAgICogU3BlY2lmeSB3aGV0aGVyIGRyb3BwaW5nIGluc2lkZSB0aGUgdHJlZSBpcyBhbGxvd2VkLiBPcHRpb25hbCB0eXBlczpcclxuICAgICogIC0gYm9vbGVhblxyXG4gICAgKiAgLSAoZWxlbWVudDphbnksIHRvOntwYXJlbnQ6VHJlZU5vZGUsIGluZGV4Om51bWJlcn0pOmJvb2xlYW5cclxuICAgICAgICAgQSBmdW5jdGlvbiB0aGF0IHJlY2VpdmVzIHRoZSBkcmFnZ2VkIGVsZW1lbnQsIGFuZCB0aGUgZHJvcCBsb2NhdGlvbiAocGFyZW50IG5vZGUgYW5kIGluZGV4IGluc2lkZSB0aGUgcGFyZW50KSxcclxuICAgICAgICAgYW5kIHJldHVybnMgdHJ1ZSBvciBmYWxzZS5cclxuXHJcbiAgICAqICoqRGVmYXVsdCBWYWx1ZTogdHJ1ZSoqXHJcblxyXG4gICAgZXhhbXBsZTpcclxuICAgIGBgYFxyXG4gICAgKiBvcHRpb25zID0ge1xyXG4gICAgKiAgYWxsb3dEcm9wOiAoZWxlbWVudCwge3BhcmVudCwgaW5kZXh9KSA9PiBwYXJlbnQuaXNMZWFmXHJcbiAgICAqIH1cclxuICAgIGBgYFxyXG4gICAqL1xyXG4gICBhbGxvd0Ryb3A/OiBib29sZWFuIHwgSUFsbG93RHJvcEZuO1xyXG4gICAgLyoqXHJcbiAgICBCb29sZWFuIGZsYWcgdG8gYWxsb3cgYWRkaW5nIGFuZCByZW1vdmluZyBpcy1kcmFnZ2luZy1vdmVyIGFuZCBpcy1kcmFnZ2luZy1vdmVyLWRpc2FibGVkIGNsYXNzZXMuXHJcblxyXG4gICAgSWYgc2V0IHRvIGZhbHNlIGl0IHdpbGwgbm90IGFkZCB0aGUgYWJvdmUgbWVudGlvbmVkIGNsYXNzZXMgYW5kIHlvdSBzaG91bGQgaGFuZGxlIHRoZSBzdHlsaW5nIHlvdXJzZWxmIHdpdGggY3NzIGFuZCBpblxyXG4gICAgdGhlIGFjdGlvbk1hcHBpbmcgLT4gbW91c2UgLT4gZHJhZ0VudGVyLCBkcmFnTGVhdmVcclxuXHJcbiAgICAqICoqRGVmYXVsdCBWYWx1ZTogdHJ1ZSoqXHJcblxyXG4gICAgZXhhbXBsZTpcclxuICAgIGBgYFxyXG4gICAgKiBvcHRpb25zID0ge1xyXG4gICAgKiAgIGFsbG93RHJvcDogdHJ1ZSxcclxuICAgICogICBhbGxvd0RyYWdvdmVyU3R5bGluZzogZmFsc2VcclxuICAgICogfVxyXG4gICAgYGBgXHJcbiAgICAqL1xyXG4gICBhbGxvd0RyYWdvdmVyU3R5bGluZz86IGJvb2xlYW47XHJcbiAgIC8qKlxyXG4gICAqIFNwZWNpZnkgcGFkZGluZyBwZXIgbm9kZSAoaW50ZWdlcikuXHJcbiAgICBFYWNoIG5vZGUgd2lsbCBoYXZlIHBhZGRpbmctbGVmdCB2YWx1ZSBvZiBsZXZlbCAqIGxldmVsUGFkZGluZywgaW5zdGVhZCBvZiB1c2luZyB0aGUgZGVmYXVsdCBwYWRkaW5nIGZvciBjaGlsZHJlbi5cclxuXHJcbiAgICBUaGlzIG9wdGlvbiBpcyBnb29kIGZvciBleGFtcGxlIGZvciBhbGxvd2luZyB3aG9sZSByb3cgc2VsZWN0aW9uLCBldGMuXHJcblxyXG4gICAgWW91IGNhbiBhbHRlcm5hdGl2ZWx5IHVzZSB0aGUgdHJlZS1ub2RlLWxldmVsLVggY2xhc3NlcyB0byBnaXZlIHBhZGRpbmcgb24gYSBwZXItbGV2ZWwgYmFzaXMuXHJcblxyXG4gICAgKiAqKkRlZmF1bHQgdmFsdWU6IDAqKlxyXG4gICAqL1xyXG4gICBsZXZlbFBhZGRpbmc/OiBudW1iZXI7XHJcbiAgIC8qKlxyXG4gICAgKiBTcGVjaWZ5IGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgY2xhc3MgcGVyIG5vZGUuIFVzZWZ1bCBmb3Igc3R5bGluZyB0aGUgbm9kZXMgaW5kaXZpZHVhbGx5LlxyXG5cclxuICAgICAgRXhhbXBsZTpcclxuICAgICAgYGBgXHJcbiAgICAgICogb3B0aW9ucyA9IHtcclxuICAgICAgKiAgIG5vZGVDbGFzczogKG5vZGU6VHJlZU5vZGUpID0+IHtcclxuICAgICAgKiAgICAgcmV0dXJuICdpY29uLScgKyBub2RlLmRhdGEuaWNvbjtcclxuICAgICAgKiAgIH1cclxuICAgICAgKiB9XHJcbiAgICAgIGBgYFxyXG4gICAgKi9cclxuICAgbm9kZUNsYXNzPzogKG5vZGU6IFRyZWVOb2RlKSA9PiBzdHJpbmc7XHJcbiAgIC8qKlxyXG4gICAgQm9vbGVhbiBmbGFnIHRvIHVzZSB0aGUgdmlydHVhbCBzY3JvbGwgb3B0aW9uLlxyXG5cclxuICAgIFRvIHVzZSB0aGlzIG9wdGlvbiwgeW91IG11c3Qgc3VwcGx5IHRoZSBoZWlnaHQgb2YgdGhlIGNvbnRhaW5lciwgYW5kIHRoZSBoZWlnaHQgb2YgZWFjaCBub2RlIGluIHRoZSB0cmVlLlxyXG5cclxuICAgIFlvdSBjYW4gYWxzbyBzcGVjaWZ5IGhlaWdodCBmb3IgdGhlIGRyb3BTbG90IHdoaWNoIGlzIGxvY2F0ZWQgYmV0d2VlbiBub2Rlcy5cclxuXHJcbiAgICAqICoqRGVmYXVsdCBWYWx1ZTogZmFsc2UqKlxyXG5cclxuICAgIGV4YW1wbGU6XHJcbiAgICBgYGBcclxuICAgICogb3B0aW9ucyA9IHtcclxuICAgICogICB1c2VWaXJ0dWFsU2Nyb2xsOiB0cnVlLFxyXG4gICAgKiAgIG5vZGVIZWlnaHQ6IChub2RlOiBUcmVlTm9kZSkgPT4gbm9kZS5teUhlaWdodCxcclxuICAgICogICBkcm9wU2xvdEhlaWdodDogM1xyXG4gICAgKiB9XHJcbiAgICBgYGBcclxuICAgICovXHJcbiAgIHVzZVZpcnR1YWxTY3JvbGw/OiBib29sZWFuO1xyXG4gICAvKipcclxuICAgICogRm9yIHVzZSB3aXRoIGB1c2VWaXJ0dWFsU2Nyb2xsYCBvcHRpb24uXHJcbiAgICAqIFNwZWNpZnkgYSBoZWlnaHQgZm9yIG5vZGVzIGluIHBpeGVscy4gQ291bGQgYmUgZWl0aGVyOlxyXG4gICAgKiAtIG51bWJlclxyXG4gICAgKiAtIChub2RlOiBUcmVlTm9kZSkgPT4gbnVtYmVyXHJcblxyXG4gICAgKiAqKkRlZmF1bHQgVmFsdWU6IDIyKipcclxuICAgICovXHJcbiAgIG5vZGVIZWlnaHQ/OiBudW1iZXIgfCBJTm9kZUhlaWdodEZuO1xyXG4gICAvKipcclxuICAgICogRm9yIHVzZSB3aXRoIGB1c2VWaXJ0dWFsU2Nyb2xsYCBvcHRpb24uXHJcbiAgICAqIFNwZWNpZnkgYSBoZWlnaHQgZm9yIGRyb3Agc2xvdHMgKGxvY2F0ZWQgYmV0d2VlbiBub2RlcykgaW4gcGl4ZWxzXHJcblxyXG4gICAgKiAqKkRlZmF1bHQgVmFsdWU6IDIqKlxyXG4gICAgKi9cclxuICAgZHJvcFNsb3RIZWlnaHQ/OiBudW1iZXI7XHJcbiAgIC8qKlxyXG4gICAgKiBCb29sZWFuIHdoZXRoZXIgb3Igbm90IHRvIGFuaW1hdGUgZXhwYW5kIC8gY29sbGFwc2Ugb2Ygbm9kZXMuXHJcblxyXG4gICAgKiAqKkRlZmF1bHQgVmFsdWU6IGZhbHNlKipcclxuICAgICovXHJcbiAgIGFuaW1hdGVFeHBhbmQ/OiBib29sZWFuO1xyXG4gICAvKipcclxuICAgICogU3BlZWQgb2YgZXhwYW5kIGFuaW1hdGlvbiAoZGVzY3JpYmVkIGluIHBpeGVscyBwZXIgMTcgbXMpLlxyXG5cclxuICAgICogKipEZWZhdWx0IFZhbHVlOiAzMCoqXHJcbiAgICAqL1xyXG4gICBhbmltYXRlU3BlZWQ/OiBudW1iZXI7XHJcbiAgIC8qKlxyXG4gICAgKiBJbmNyZWFzZSBvZiBleHBhbmQgYW5pbWF0aW9uIHNwZWVkIChkZXNjcmliZWQgaW4gbXVsdGlwbHkgcGVyIDE3IG1zKS5cclxuXHJcbiAgICAqICoqRGVmYXVsdCBWYWx1ZTogMS4yKipcclxuICAgICovXHJcbiAgIGFuaW1hdGVBY2NlbGVyYXRpb24/OiBudW1iZXI7XHJcbiAgIC8qKlxyXG4gICAgKiBXaGV0aGVyIHRvIHNjcm9sbCB0byB0aGUgbm9kZSB0byBtYWtlIGl0IHZpc2libGUgd2hlbiBpdCBpcyBhY3RpdmF0ZWQuXHJcblxyXG4gICAgKiAqKkRlZmF1bHQgVmFsdWU6IHRydWUqKlxyXG4gICAgKi9cclxuICAgc2Nyb2xsT25BY3RpdmF0ZT86IGJvb2xlYW47XHJcbiAgIC8qKlxyXG4gICAgKiBGdW5jdGlvbiB0byBjbG9uZSBhIG5vZGUuXHJcbiAgICAqIFJlY2VpdmVzIGEgVHJlZU5vZGUgb2JqZWN0LCBhbmQgcmV0dXJucyBhIG5vZGUgb2JqZWN0IChvbmx5IHRoZSBkYXRhKS5cclxuICAgICogVGhpcyBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCB3aGVuIGNvcHlpbmcgYSBub2RlIGluc2lkZSB0aGUgdHJlZSxcclxuICAgICogYnkgZWl0aGVyIGNhbGxpbmcgY29weU5vZGUsIG9yIGJ5IGRyYWdnaW5nIGFuZCBob2xkaW5nIHRoZSBjdHJsIGtleVxyXG4gICAgKlxyXG4gICAgKiBGb3IgZXhhbXBsZTpcclxuICAgICAgYGBgXHJcbiAgICAgICAgb3B0aW9uczogSVRyZWVPcHRpb25zID0ge1xyXG4gICAgICAgICAgZ2V0Tm9kZUNsb25lOiAobm9kZSkgPT4gKHtcclxuICAgICAgICAgICAgLi4ubm9kZS5kYXRhLFxyXG4gICAgICAgICAgICBpZDogdXVpZC52NCgpLFxyXG4gICAgICAgICAgICBuYW1lOiBgY29weSBvZiAke25vZGUuZGF0YS5uYW1lfWBcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgfTtcclxuICAgICAgYGBgXHJcbiAgICAqXHJcbiAgICAqICoqRGVmYXVsdCBWYWx1ZTogY2xvbmUgdGhlIG5vZGUgdXNpbmcgT2JqZWN0LmFzc2lnbiwgYW5kIHJlbW92ZSAnaWQnIHByb3BlcnR5KipcclxuICAgICovXHJcbiAgICBnZXROb2RlQ2xvbmU/OiAobm9kZTogVHJlZU5vZGUpID0+IGFueTtcclxuICAgIC8qKlxyXG4gICAgICogTWFrZXMgdGhlIHRyZWUgcmlnaHQtdG8tbGVmdC5cclxuICAgICAqIFRoaXMgaW5jbHVkZSBkaXJlY3Rpb24sIGV4cGFuZGVyIHN0eWxlLCBhbmQgY2hhbmdlIGtleSBiaW5kaW5nIChyaWdodCBrZXkgY29sbGFwc2UgYW5kIGxlZnQga2V5IGV4cGFuZHMgaW5zdGVhZCBvZiB2aWNlLXZlcnNhKVxyXG4gICAgICovXHJcbiAgICBydGw/OiBib29sZWFuO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTcGVjaWZpZXMgaWQgb2Ygcm9vdCBub2RlICh2aXJ0dWFsUm9vdClcclxuICAgICAqL1xyXG4gICAgcm9vdElkPzogYW55O1xyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRvIGRpc3BsYXkgYSBjaGVja2JveCBuZXh0IHRvIHRoZSBub2RlIG9yIG5vdFxyXG4gICAgICovXHJcbiAgICB1c2VDaGVja2JveD86IGJvb2xlYW47XHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdG8gdXNlIG1hc3RlciBjaGVja2JveGVzIG1lY2hhbmlzbSBpZiB0aGUgdXNlQ2hlY2tib3ggaXMgc2V0IHRvIHRydWVcclxuICAgICAqL1xyXG4gICAgdXNlVHJpU3RhdGU/OiBib29sZWFuO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgSFRNTCBlbGVtZW50IHRoYXQgaXMgdGhlIHNjcm9sbCBjb250YWluZXIgZm9yIHRoZSB0cmVlLlxyXG4gICAgICogVGhlIGRlZmF1bHQgYmVoYXZpb3VyIGlzIHRvIHdyYXAgdGhlIHRyZWUgd2l0aCBhIGNvbnRhaW5lciB0aGF0IGhhcyBvdmVyZmxvdzogaGlkZGVuLFxyXG4gICAgICogYW5kIHRoZW4gdGhlIHNjcm9sbGluZyBjb250YWluZXIgaXMgdGhlIHZpZXdwb3J0IGluc2lkZSB0aGUgdHJlZSBjb21wb25lbnRcclxuICAgICAqL1xyXG4gICAgc2Nyb2xsQ29udGFpbmVyPzogSFRNTEVsZW1lbnQ7XHJcbiB9XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElUcmVlTm9kZSB7XHJcbiAgLy8gcHJvcGVydGllc1xyXG4gIC8qKlxyXG4gICAqIFBhcmVudCBub2RlXHJcbiAgICovXHJcbiAgcGFyZW50OiBJVHJlZU5vZGU7XHJcbiAgLyoqXHJcbiAgICogVGhlIHZhbHVlIG9mIHRoZSBub2RlJ3MgZmllbGQgdGhhdCBpcyB1c2VkIGZvciBkaXNwbGF5aW5nIGl0cyBjb250ZW50LlxyXG4gICAqIEJ5IGRlZmF1bHQgJ25hbWUnLCB1bmxlc3Mgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGUgb3B0aW9uc1xyXG4gICAqL1xyXG4gIGRpc3BsYXlGaWVsZDogc3RyaW5nO1xyXG4gIC8qKlxyXG4gICAqIFRoZSBjaGlsZHJlbiBvZiB0aGUgbm9kZS5cclxuICAgKiBCeSBkZWZhdWx0IGlzIGRldGVybWluZWQgYnkgJ25vZGUuZGF0YS5jaGlsZHJlbicsIHVubGVzcyBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoZSBvcHRpb25zXHJcbiAgICovXHJcbiAgY2hpbGRyZW46IElUcmVlTm9kZVtdO1xyXG4gIC8qKlxyXG4gICAqIFBvaW50ZXIgdG8gdGhlIG9yaWdpbmFsIGRhdGEuXHJcbiAgICovXHJcbiAgZGF0YTogYW55O1xyXG4gIC8qKlxyXG4gICAqIFBvaW50ZXIgdG8gdGhlIEVsZW1lbnRSZWYgb2YgdGhlIFRyZWVOb2RlQ29tcG9uZW50IHRoYXQncyBkaXNwbGF5aW5nIHRoaXMgbm9kZVxyXG4gICAqL1xyXG4gIGVsZW1lbnRSZWY6IGFueTtcclxuICAvKipcclxuICAgKiBMZXZlbCBpbiB0aGUgdHJlZSAoc3RhcnRzIGZyb20gMSkuXHJcbiAgICovXHJcbiAgbGV2ZWw6IG51bWJlcjtcclxuICAvKipcclxuICAgKiBQYXRoIGluIHRoZSB0cmVlOiBBcnJheSBvZiBJRHMuXHJcbiAgICovXHJcbiAgcGF0aDogc3RyaW5nW107XHJcbiAgLyoqXHJcbiAgICogaW5kZXggb2YgdGhlIG5vZGUgaW5zaWRlIGl0cyBwYXJlbnQncyBjaGlsZHJlblxyXG4gICAqL1xyXG4gIGluZGV4OiBudW1iZXI7XHJcbiAgLyoqXHJcbiAgICogQSB1bmlxdWUga2V5IG9mIHRoaXMgbm9kZSBhbW9uZyBpdHMgc2libGluZ3MuXHJcbiAgICogQnkgZGVmYXVsdCBpdCdzIHRoZSAnaWQnIG9mIHRoZSBvcmlnaW5hbCBub2RlLCB1bmxlc3Mgc3RhdGVkIG90aGVyd2lzZSBpbiBvcHRpb25zLmlkRmllbGRcclxuICAgKi9cclxuICBpZDogSURUeXBlO1xyXG5cclxuICAvLyBoZWxwZXJzXHJcbiAgaXNFeHBhbmRlZDogYm9vbGVhbjtcclxuICBpc0FjdGl2ZTogYm9vbGVhbjtcclxuICBpc0ZvY3VzZWQ6IGJvb2xlYW47XHJcbiAgaXNDb2xsYXBzZWQ6IGJvb2xlYW47XHJcbiAgaXNMZWFmOiBib29sZWFuO1xyXG4gIGhhc0NoaWxkcmVuOiBib29sZWFuO1xyXG4gIGlzUm9vdDogYm9vbGVhbjtcclxuXHJcbiAgLy8gdHJhdmVyc2luZ1xyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSBza2lwSGlkZGVuIHdoZXRoZXIgdG8gc2tpcCBoaWRkZW4gbm9kZXNcclxuICAgKiBAcmV0dXJucyBuZXh0IHNpYmxpbmcgKG9yIG51bGwpXHJcbiAgICovXHJcbiAgZmluZE5leHRTaWJsaW5nKHNraXBIaWRkZW4pOiBJVHJlZU5vZGU7XHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHNraXBIaWRkZW4gd2hldGhlciB0byBza2lwIGhpZGRlbiBub2Rlc1xyXG4gICAqIEByZXR1cm5zIHByZXZpb3VzIHNpYmxpbmcgKG9yIG51bGwpXHJcbiAgICovXHJcbiAgZmluZFByZXZpb3VzU2libGluZyhza2lwSGlkZGVuKTogSVRyZWVOb2RlO1xyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSBza2lwSGlkZGVuIHdoZXRoZXIgdG8gc2tpcCBoaWRkZW4gbm9kZXNcclxuICAgKiBAcmV0dXJucyBmaXJzdCBjaGlsZCAob3IgbnVsbClcclxuICAgKi9cclxuICBnZXRGaXJzdENoaWxkKHNraXBIaWRkZW4pOiBJVHJlZU5vZGU7XHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHNraXBIaWRkZW4gd2hldGhlciB0byBza2lwIGhpZGRlbiBub2Rlc1xyXG4gICAqIEByZXR1cm5zIGxhc3QgY2hpbGQgKG9yIG51bGwpXHJcbiAgICovXHJcbiAgZ2V0TGFzdENoaWxkKHNraXBIaWRkZW4pOiBJVHJlZU5vZGU7XHJcbiAgLyoqXHJcbiAgICogRmluZHMgdGhlIHZpc3VhbGx5IG5leHQgbm9kZSBpbiB0aGUgdHJlZS5cclxuICAgKiBAcGFyYW0gZ29JbnNpZGUgd2hldGhlciB0byBsb29rIGZvciBjaGlsZHJlbiBvciBqdXN0IHNpYmxpbmdzXHJcbiAgICogQHJldHVybnMgbmV4dCBub2RlLlxyXG4gICAqL1xyXG4gIGZpbmROZXh0Tm9kZShnb0luc2lkZTogYm9vbGVhbik6IElUcmVlTm9kZTtcclxuICAvKipcclxuICAgKiBGaW5kcyB0aGUgdmlzdWFsbHkgcHJldmlvdXMgbm9kZSBpbiB0aGUgdHJlZS5cclxuICAgKiBAcGFyYW0gc2tpcEhpZGRlbiB3aGV0aGVyIHRvIHNraXAgaGlkZGVuIG5vZGVzXHJcbiAgICogQHJldHVybnMgcHJldmlvdXMgbm9kZS5cclxuICAgKi9cclxuICBmaW5kUHJldmlvdXNOb2RlKHNraXBIaWRkZW4pOiBJVHJlZU5vZGU7XHJcblxyXG4gIC8qKlxyXG4gICAqIEByZXR1cm5zICAgICAgdHJ1ZSBpZiB0aGlzIG5vZGUgaXMgYSBkZXNjZW5kYW50IG9mIHRoZSBwYXJhbWV0ZXIgbm9kZVxyXG4gICAqL1xyXG4gIGlzRGVzY2VuZGFudE9mKG5vZGU6IElUcmVlTm9kZSk6IGJvb2xlYW47XHJcblxyXG4gIC8qKlxyXG4gICAqIEByZXR1cm5zICAgICAgaW4gY2FzZSBsZXZlbFBhZGRpbmcgb3B0aW9uIGlzIHN1cHBsaWVkLCByZXR1cm5zIHRoZSBjdXJyZW50IG5vZGUncyBwYWRkaW5nXHJcbiAgICovXHJcbiAgZ2V0Tm9kZVBhZGRpbmcoKTogc3RyaW5nO1xyXG5cclxuICAvKipcclxuICAgKiBAcmV0dXJucyAgICAgIGluIGNhc2Ugbm9kZUNsYXNzIG9wdGlvbiBpcyBzdXBwbGllZCwgcmV0dXJucyB0aGUgY3VycmVudCBub2RlJ3MgY2xhc3NcclxuICAgKi9cclxuICBnZXRDbGFzcygpOiBzdHJpbmc7XHJcblxyXG4gIC8vIGFjdGlvbnNcclxuICAvKipcclxuICAgKiBFeHBhbmRzIC8gQ29sbGFwc2VzIHRoZSBub2RlXHJcbiAgICovXHJcbiAgdG9nZ2xlRXhwYW5kZWQoKTtcclxuICAvKipcclxuICAgKiBFeHBhbmRzIHRoZSBub2RlXHJcbiAgICovXHJcbiAgZXhwYW5kKCk7XHJcbiAgLyoqXHJcbiAgICogQ29sbGFwc2VzIHRoZSBub2RlXHJcbiAgICovXHJcbiAgY29sbGFwc2UoKTtcclxuICAvKipcclxuICAgKiBFeHBhbmRzIGFsbCBhbmNlc3RvcnMgb2YgdGhlIG5vZGVcclxuICAgKi9cclxuICBlbnN1cmVWaXNpYmxlKCk7XHJcbiAgLyoqXHJcbiAgICogQWN0aXZhdGVzIC8gRGVhY3RpdmF0ZXMgdGhlIG5vZGUgKHNlbGVjdHMgLyBkZXNlbGVjdHMpXHJcbiAgICovXHJcbiAgdG9nZ2xlQWN0aXZhdGVkKG11bHRpKTtcclxuICAvKipcclxuICAgKiBGb2N1cyBvbiB0aGUgbm9kZVxyXG4gICAqL1xyXG4gIGZvY3VzKCk7XHJcbiAgLyoqXHJcbiAgICogQmx1ciAodW5mb2N1cykgdGhlIG5vZGVcclxuICAgKi9cclxuICBibHVyKCk7XHJcbiAgLyoqXHJcbiAgICogSGlkZXMgdGhlIG5vZGVcclxuICAgKi9cclxuICBoaWRlKCk7XHJcbiAgLyoqXHJcbiAgICogTWFrZXMgdGhlIG5vZGUgdmlzaWJsZVxyXG4gICAqL1xyXG4gIHNob3coKTtcclxuICAvKipcclxuICAgKiBAcGFyYW0gdmFsdWUgIGlmIHRydWUgbWFrZXMgdGhlIG5vZGUgaGlkZGVuLCBvdGhlcndpc2UgdmlzaWJsZVxyXG4gICAqL1xyXG4gIHNldElzSGlkZGVuKHZhbHVlOiBib29sZWFuKTtcclxuICAvKipcclxuICAgKiBTY3JvbGwgdGhlIHNjcmVlbiB0byBtYWtlIHRoZSBub2RlIHZpc2libGVcclxuICAgKi9cclxuICBzY3JvbGxJbnRvVmlldygpO1xyXG4gIC8qKlxyXG4gICAqIEZpcmUgYW4gZXZlbnQgdG8gdGhlIHJlbmRlcmVyIG9mIHRoZSB0cmVlIChpZiBpdCB3YXMgcmVnaXN0ZXJlZClcclxuICAgKi9cclxuICBmaXJlRXZlbnQoZXZlbnQ6IGFueSk7XHJcbiAgLyoqXHJcbiAgICogSW52b2tlcyBhIG1ldGhvZCBmb3IgZXZlcnkgbm9kZSB1bmRlciB0aGlzIG9uZSAtIGRlcHRoIGZpcnN0XHJcbiAgICogQHBhcmFtIGZuICBhIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgdGhlIG5vZGVcclxuICAgKi9cclxuICBkb0ZvckFsbChmbjogKG5vZGU6IElUcmVlTm9kZSkgPT4gYW55KTtcclxuICAvKipcclxuICAgKiBleHBhbmQgYWxsIG5vZGVzIHVuZGVyIHRoaXMgb25lXHJcbiAgICovXHJcbiAgZXhwYW5kQWxsKCk7XHJcbiAgLyoqXHJcbiAgICogY29sbGFwc2UgYWxsIG5vZGVzIHVuZGVyIHRoaXMgb25lXHJcbiAgICovXHJcbiAgY29sbGFwc2VBbGwoKTtcclxuICAvKipcclxuICAgKiBzZXRzIHRoZSBub2RlIHRvIGFjdGl2ZSAvIGluYWN0aXZlIGFjY29yZGluZyB0byB0aGUgdmFsdWUuXHJcbiAgICogSWYgbXVsdGkgaXMgdHJ1ZSAoZGVmYXVsdCBmYWxzZSkgLSBkb2VzIGEgbXVsdGlzZWxlY3QuXHJcbiAgICovXHJcbiAgc2V0SXNBY3RpdmUodmFsdWU6IGJvb2xlYW4sIG11bHRpPzogYm9vbGVhbik7XHJcbiAgLyoqXHJcbiAgICogc2V0cyB0aGUgbm9kZSB0byBiZSBhY3RpdmUgYW5kIG1ha2VzIHN1cmUgaXQncyB2aXNpYmxlIGJ5IGV4cGFuZGluZyBhbGwgbm9kZXMgYWJvdmUgaXQgYW5kIHNjcm9sbGluZyBpdCBpbnRvIHZpZXcuXHJcbiAgICogVmVyeSBzaW1pbGFyIHRvIGNhbGxpbmcgYGFjdGl2YXRlYCwgYGVuc3VyZVZpc2libGVgIGFuZCBgc2Nyb2xsSW50b1ZpZXdgIG1ldGhvZHMuXHJcbiAgICogSWYgbXVsdGkgaXMgdHJ1ZSAoZGVmYXVsdCBmYWxzZSkgLSBkb2VzIGEgbXVsdGlzZWxlY3QuXHJcbiAgICovXHJcbiAgc2V0QWN0aXZlQW5kVmlzaWJsZShtdWx0aTogYm9vbGVhbik7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSVRyZWVNb2RlbCB7XHJcbiAgLy8gcHJvcGVydGllc1xyXG4gIC8qKlxyXG4gICAqIEFsbCByb290IG5vZGVzXHJcbiAgICovXHJcbiAgcm9vdHM6IElUcmVlTm9kZVtdO1xyXG4gIC8qKlxyXG4gICAqIEN1cnJlbnQgZm9jdXNlZCBub2RlXHJcbiAgICovXHJcbiAgZm9jdXNlZE5vZGU6IElUcmVlTm9kZTtcclxuICAvKipcclxuICAgKiBPcHRpb25zIHRoYXQgd2VyZSBwYXNzZWQgdG8gdGhlIHRyZWUgY29tcG9uZW50XHJcbiAgICovXHJcbiAgb3B0aW9uczogSVRyZWVPcHRpb25zO1xyXG5cclxuICAvKipcclxuICAgKiBJcyB0aGUgdHJlZSBjdXJyZW50bHkgZm9jdXNlZFxyXG4gICAqL1xyXG4gIGlzRm9jdXNlZDogYm9vbGVhbjtcclxuICAvKipcclxuICAgKiBAcmV0dXJucyBDdXJyZW50IGFjdGl2ZSBub2Rlc1xyXG4gICAqL1xyXG4gIGFjdGl2ZU5vZGVzOiBJVHJlZU5vZGVbXTtcclxuICAvKipcclxuICAgKiBAcmV0dXJucyBDdXJyZW50IGV4cGFuZGVkIG5vZGVzXHJcbiAgICovXHJcbiAgZXhwYW5kZWROb2RlczogSVRyZWVOb2RlW107XHJcblxyXG4gIC8vIGhlbHBlcnNcclxuICAvKipcclxuICAgKiBAcmV0dXJucyBDdXJyZW50IGFjdGl2ZSBub2RlLiBJZiBtdWx0aXBsZSBub2RlcyBhcmUgYWN0aXZlIC0gcmV0dXJucyB0aGUgZmlyc3Qgb25lLlxyXG4gICAqL1xyXG4gIGdldEFjdGl2ZU5vZGUoKTogSVRyZWVOb2RlO1xyXG4gIC8qKlxyXG4gICAqIEByZXR1cm5zIEN1cnJlbnQgZm9jdXNlZCBub2RlIChlaXRoZXIgaG92ZXJlZCBvciB0cmF2ZXJzZWQgd2l0aCBrZXlzKVxyXG4gICAqL1xyXG4gIGdldEZvY3VzZWROb2RlKCk6IElUcmVlTm9kZTtcclxuICAvKipcclxuICAgKiBTZXQgZm9jdXMgb24gYSBub2RlXHJcbiAgICogQHBhcmFtIHZhbHVlICB0cnVlIG9yIGZhbHNlIC0gd2hldGhlciB0byBzZXQgZm9jdXMgb3IgYmx1ci5cclxuICAgKi9cclxuICBzZXRGb2N1c2VkTm9kZShub2RlOiBJVHJlZU5vZGUpO1xyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSBza2lwSGlkZGVuICB0cnVlIG9yIGZhbHNlIC0gd2hldGhlciB0byBza2lwIGhpZGRlbiBub2Rlc1xyXG4gICAqIEByZXR1cm5zICAgICAgZmlyc3Qgcm9vdCBvZiB0aGUgdHJlZVxyXG4gICAqL1xyXG4gIGdldEZpcnN0Um9vdChza2lwSGlkZGVuPzogYm9vbGVhbik6IElUcmVlTm9kZTtcclxuICAvKipcclxuICAgKiBAcGFyYW0gc2tpcEhpZGRlbiAgdHJ1ZSBvciBmYWxzZSAtIHdoZXRoZXIgdG8gc2tpcCBoaWRkZW4gbm9kZXNcclxuICAgKiBAcmV0dXJucyAgICAgIGxhc3Qgcm9vdCBvZiB0aGUgdHJlZVxyXG4gICAqL1xyXG4gIGdldExhc3RSb290KHNraXBIaWRkZW4/OiBib29sZWFuKTogSVRyZWVOb2RlO1xyXG4gIC8qKlxyXG4gICAqIEByZXR1cm5zICAgICAgdHJ1ZSBpZiB0aGUgdHJlZSBpcyBlbXB0eVxyXG4gICAqL1xyXG4gIGlzRW1wdHlUcmVlKCk6IGJvb2xlYW47XHJcbiAgLyoqXHJcbiAgICogQHJldHVybnMgQWxsIHJvb3Qgbm9kZXMgdGhhdCBwYXNzIHRoZSBjdXJyZW50IGZpbHRlclxyXG4gICAqL1xyXG4gIGdldFZpc2libGVSb290cygpOiBJVHJlZU5vZGVbXTtcclxuICAvKipcclxuICAgKiBAcGFyYW0gICAgIHBhdGggIGFycmF5IG9mIG5vZGUgSURzIHRvIGJlIHRyYXZlcnNlZCByZXNwZWN0aXZlbHlcclxuICAgKiBAcGFyYW0gICAgIHN0YXRyTm9kZSAgb3B0aW9uYWwuIFdoaWNoIG5vZGUgdG8gc3RhcnQgdHJhdmVyc2luZyBmcm9tXHJcbiAgICogQHJldHVybnMgICBUaGUgbm9kZSwgaWYgZm91bmQgLSBudWxsIG90aGVyd2lzZVxyXG4gICAqL1xyXG4gIGdldE5vZGVCeVBhdGgocGF0aDogYW55W10sIHN0YXJ0Tm9kZT86IElUcmVlTm9kZSk6IElUcmVlTm9kZTtcclxuICAvKipcclxuICAgKiBAcGFyYW0gICAgIGlkICBub2RlIElEIHRvIGZpbmRcclxuICAgKiBAcmV0dXJucyAgIFRoZSBub2RlLCBpZiBmb3VuZCAtIG51bGwgb3RoZXJ3aXNlXHJcbiAgICovXHJcbiAgZ2V0Tm9kZUJ5SWQoaWQ6IElEVHlwZSk6IElUcmVlTm9kZTtcclxuICAvKipcclxuICAgKiBAcGFyYW0gICAgIHByZWRpY2F0ZSAtIGVpdGhlciBhbiBvYmplY3Qgb3IgYSBmdW5jdGlvbiwgdXNlZCBhcyBhIHRlc3QgY29uZGl0aW9uIG9uIGFsbCBub2Rlcy5cclxuICAgKiAgICAgICAgICAgIENvdWxkIGJlIGV2ZXJ5IHByZWRpY2F0ZSB0aGF0J3Mgc3VwcG9ydGVkIGJ5IGxvZGFzaCdzIGBmaW5kYCBtZXRob2RcclxuICAgKiBAcGFyYW0gICAgIHN0YXRyTm9kZSAgb3B0aW9uYWwuIFdoaWNoIG5vZGUgdG8gc3RhcnQgdHJhdmVyc2luZyBmcm9tXHJcbiAgICogQHJldHVybnMgICBGaXJzdCBub2RlIHRoYXQgbWF0Y2hlcyB0aGUgcHJlZGljYXRlLCBpZiBmb3VuZCAtIG51bGwgb3RoZXJ3aXNlXHJcbiAgICovXHJcbiAgZ2V0Tm9kZUJ5KHByZWRpY2F0ZTogYW55LCBzdGFydE5vZGU/OiBJVHJlZU5vZGUpOiBJVHJlZU5vZGU7XHJcbiAgLyoqXHJcbiAgICogZ2V0IHRyZWUgc3RhdGVcclxuICAgKi9cclxuICBnZXRTdGF0ZSgpOiBJVHJlZVN0YXRlO1xyXG5cclxuICAvLyBhY3Rpb25zXHJcbiAgLyoqXHJcbiAgICogRm9jdXNlcyBvciBibHVycyB0aGUgdHJlZVxyXG4gICAqIEBwYXJhbSB2YWx1ZSAgdHJ1ZSBvciBmYWxzZSAtIHdoZXRoZXIgdG8gc2V0IGZvY3VzIG9yIGJsdXIuXHJcbiAgICovXHJcbiAgc2V0Rm9jdXModmFsdWU6IGJvb2xlYW4pO1xyXG4gIC8qKlxyXG4gICAqIEZvY3VzZXMgb24gdGhlIG5leHQgbm9kZSBpbiB0aGUgdHJlZSAoc2FtZSBhcyBkb3duIGFycm93KVxyXG4gICAqL1xyXG4gIGZvY3VzTmV4dE5vZGUoKTtcclxuICAvKipcclxuICAgKiBGb2N1c2VzIG9uIHRoZSBwcmV2aW91cyBub2RlIGluIHRoZSB0cmVlIChzYW1lIGFzIHVwIGFycm93KVxyXG4gICAqL1xyXG4gIGZvY3VzUHJldmlvdXNOb2RlKCk7XHJcbiAgLyoqXHJcbiAgICogRm9jdXNlcyBvbiB0aGUgaW5uZXIgY2hpbGQgb2YgdGhlIGN1cnJlbnQgZm9jdXNlZCBub2RlIChzYW1lIGFzIHJpZ2h0IGFycm93IG9uIGFuIGV4cGFuZGVkIG5vZGUpXHJcbiAgICovXHJcbiAgZm9jdXNEcmlsbERvd24oKTtcclxuICAvKipcclxuICAgKiBGb2N1c2VzIG9uIHRoZSBwYXJlbnQgb2YgdGhlIGN1cnJlbnQgZm9jdXNlZCBub2RlIChzYW1lIGFzIGxlZnQgYXJyb3cgb24gYSBjb2xsYXBzZWQgbm9kZSlcclxuICAgKi9cclxuICBmb2N1c0RyaWxsVXAoKTtcclxuICAvKipcclxuICAgKiBNYXJrcyBpc0hpZGRlbiBmaWVsZCBpbiBhbGwgbm9kZXMgcmVjdXJzaXZlbHkgYWNjb3JkaW5nIHRvIHRoZSBmaWx0ZXIgcGFyYW0uXHJcbiAgICogSWYgYSBub2RlIGlzIG1hcmtlZCB2aXNpYmxlLCBhbGwgb2YgaXRzIGFuY2VzdG9ycyB3aWxsIGJlIG1hcmtlZCB2aXNpYmxlIGFzIHdlbGwuXHJcbiAgICogQHBhcmFtIGZpbHRlciAgZWl0aGVyIGEgc3RyaW5nIG9yIGEgZnVuY3Rpb24uXHJcbiAgICogICBJbiBjYXNlIGl0J3MgYSBzdHJpbmcsIGl0IHdpbGwgYmUgc2VhcmNoZWQgY2FzZSBpbnNlbnNpdGl2ZWx5IGluIHRoZSBub2RlJ3MgZGlzcGxheSBhdHRyaWJ1dGVcclxuICAgKiAgIEluIGNhc2UgaXQncyBhIGZ1bmN0aW9uLCBpdCB3aWxsIGJlIHBhc3NlZCB0aGUgbm9kZSwgYW5kIHNob3VsZCByZXR1cm4gdHJ1ZSBpZiB0aGUgbm9kZSBzaG91bGQgYmUgdmlzaWJsZSwgZmFsc2Ugb3RoZXJ3aXNlXHJcbiAgICogQHBhcmFtIGF1dG9TaG93ICBpZiB0cnVlLCBtYWtlIHN1cmUgYWxsIG5vZGVzIHRoYXQgcGFzc2VkIHRoZSBmaWx0ZXIgYXJlIHZpc2libGVcclxuICAgKi9cclxuICBmaWx0ZXJOb2RlcyhmaWx0ZXIsIGF1dG9TaG93PzogYm9vbGVhbik7XHJcbiAgLyoqXHJcbiAgICogTWFya3MgYWxsIG5vZGVzIGlzSGlkZGVuID0gZmFsc2VcclxuICAgKi9cclxuICBjbGVhckZpbHRlcigpO1xyXG4gIC8qKlxyXG4gICAqIG1vdmVzIGEgbm9kZSBmcm9tIG9uZSBsb2NhdGlvbiBpbiB0aGUgdHJlZSB0byBhbm90aGVyXHJcbiAgICogQHBhcmFtIG5vZGUgZGVzY3JpYmVzIHdoaWNoIG5vZGUgbmVlZHMgdG8gYmUgbW92ZWRcclxuICAgKiBAcGFyYW0gdG8gZGVzY3JpYmVzIHdoZXJlIHRvIG1vdmUgdGhlIG5vZGUgdG8uXHJcbiAgICogQHBhcmFtIGZyb20gZGVzY3JpYmVzIHdoZXJlIHRvIG1vdmUgdGhlIG5vZGUgZnJvbS5cclxuICAgKiBDb250YWlucyBhICdwYXJlbnQnIG5vZGUsIGFuICdpbmRleCcsIGFuZCBhICdkcm9wT25Ob2RlJyAtIHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gZHJvcHBpbmcgYmV0d2VlbiBub2RlcyBvciBvbiB0aGUgbm9kZVxyXG4gICAqL1xyXG4gIG1vdmVOb2RlKG5vZGU6IElUcmVlTm9kZSwgdG86IHtwYXJlbnQ6IElUcmVlTm9kZSwgaW5kZXg6IG51bWJlciwgZHJvcE9uTm9kZTogYm9vbGVhbn0sIGZyb206IHtwYXJlbnQ6IElUcmVlTm9kZSwgaW5kZXg6IG51bWJlcn0pO1xyXG4gIC8qKlxyXG4gICAqIEludm9rZXMgYSBtZXRob2QgZm9yIGV2ZXJ5IG5vZGUgb2YgdGhlIHRyZWUgLSBkZXB0aCBmaXJzdFxyXG4gICAqIEBwYXJhbSBmbiAgYSBmdW5jdGlvbiB0aGF0IHJlY2VpdmVzIHRoZSBub2RlXHJcbiAgICovXHJcbiAgZG9Gb3JBbGwoZm46IChub2RlOiBJVHJlZU5vZGUpID0+IGFueSk7XHJcbiAgLyoqXHJcbiAgICogZXhwYW5kIGFsbCBub2Rlc1xyXG4gICAqL1xyXG4gIGV4cGFuZEFsbCgpO1xyXG4gIC8qKlxyXG4gICAqIGNvbGxhcHNlIGFsbCBub2Rlc1xyXG4gICAqL1xyXG4gIGNvbGxhcHNlQWxsKCk7XHJcbiAgLyoqXHJcbiAgICogc2V0IHRyZWUgc3RhdGVcclxuICAgKi9cclxuICBzZXRTdGF0ZShzdGF0ZTogSVRyZWVTdGF0ZSk7XHJcblxyXG4gIHN1YnNjcmliZVRvU3RhdGUoZm46IChzdGF0ZTogSVRyZWVTdGF0ZSkgPT4gYW55KTtcclxufVxyXG4vKipcclxuICogVGhpcyBpcyB0aGUgaW50ZXJmYWNlIG9mIHRoZSBUcmVlTm9kZURyYWcgc2VydmljZVxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBJVHJlZU5vZGVEcmFnIHtcclxuICAvKipcclxuICAgKiBHZXRzIHRoZSBjdXJyZW50IGRyYWdnZWQgbm9kZS4gVXNlZnVsIGZvciBvdmVycmlkaW5nIHRoZSBkcm9wIGFjdGlvbi5cclxuICAgKiBAcGFyYW0gbm9kZSAgVGhlIHBhcmVudCBub2RlIG9mIHRoZSBjdXJyZW50IGRyYWdnZWQgbm9kZVxyXG4gICAqIEBwYXJhbSBpbmRleCAgVGhlIGluZGV4IGluc2lkZSBwYXJlbnQncyBjaGlsZHJlbiwgb2YgdGhlIGN1cnJlbnQgZHJhZ2dlZCBub2RlXHJcbiAgICovXHJcbiAgZ2V0RHJhZ05vZGUoKTogeyBub2RlOiBUcmVlTm9kZSwgaW5kZXg6IG51bWJlciB9O1xyXG59XHJcbiJdfQ==