import { Directive, TemplateRef, ViewContainerRef, Input, Injectable, ɵɵdefineInjectable, Component, ViewEncapsulation, ElementRef, NgZone, EventEmitter, ContentChild, ViewChild, Output, HostListener, Renderer2, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { autorun, reaction, computed as computed$1, observable as observable$1, action as action$1 } from 'mobx';
import { defaultsDeep, get, omit, isNumber, some, every, first, last, compact, find, isString, isFunction, throttle, includes, pick } from 'lodash-es';

/**
 * @fileoverview added by tsickle
 * Generated from: lib/mobx-angular/tree-mobx-autorun.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TreeMobxAutorunDirective {
    /**
     * @param {?} templateRef
     * @param {?} viewContainer
     */
    constructor(templateRef, viewContainer) {
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
        this.templateBindings = {};
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.view = this.viewContainer.createEmbeddedView(this.templateRef);
        if (this.dispose) {
            this.dispose();
        }
        if (this.shouldDetach()) {
            this.view.detach();
        }
        this.autoDetect(this.view);
    }
    /**
     * @return {?}
     */
    shouldDetach() {
        return this.treeMobxAutorun && this.treeMobxAutorun.detach;
    }
    /**
     * @param {?} view
     * @return {?}
     */
    autoDetect(view) {
        this.dispose = autorun((/**
         * @return {?}
         */
        () => view.detectChanges()));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.dispose) {
            this.dispose();
        }
    }
}
TreeMobxAutorunDirective.decorators = [
    { type: Directive, args: [{ selector: '[treeMobxAutorun]' },] }
];
/** @nocollapse */
TreeMobxAutorunDirective.ctorParameters = () => [
    { type: TemplateRef },
    { type: ViewContainerRef }
];
TreeMobxAutorunDirective.propDecorators = {
    treeMobxAutorun: [{ type: Input }]
};
if (false) {
    /**
     * @type {?}
     * @protected
     */
    TreeMobxAutorunDirective.prototype.templateBindings;
    /**
     * @type {?}
     * @protected
     */
    TreeMobxAutorunDirective.prototype.dispose;
    /**
     * @type {?}
     * @protected
     */
    TreeMobxAutorunDirective.prototype.view;
    /** @type {?} */
    TreeMobxAutorunDirective.prototype.treeMobxAutorun;
    /**
     * @type {?}
     * @protected
     */
    TreeMobxAutorunDirective.prototype.templateRef;
    /**
     * @type {?}
     * @protected
     */
    TreeMobxAutorunDirective.prototype.viewContainer;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/constants/keys.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const KEYS = {
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
    ENTER: 13,
    SPACE: 32,
    CONTEXT_MENU: 32
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/models/tree-options.model.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function IActionHandler() { }
const ɵ0 = /**
 * @param {?} tree
 * @param {?} node
 * @param {?} $event
 * @return {?}
 */
(tree, node, $event) => node && node.toggleActivated(), ɵ1 = /**
 * @param {?} tree
 * @param {?} node
 * @param {?} $event
 * @return {?}
 */
(tree, node, $event) => node && node.toggleActivated(true), ɵ2 = /**
 * @param {?} tree
 * @param {?} node
 * @param {?} $event
 * @return {?}
 */
(tree, node, $event) => node && node.toggleSelected(), ɵ3 = /**
 * @param {?} tree
 * @param {?} node
 * @param {?} $event
 * @return {?}
 */
(tree, node, $event) => node.setIsActive(true), ɵ4 = /**
 * @param {?} tree
 * @param {?} node
 * @param {?} $event
 * @return {?}
 */
(tree, node, $event) => node.setIsActive(false), ɵ5 = /**
 * @param {?} tree
 * @param {?} node
 * @param {?} $event
 * @return {?}
 */
(tree, node, $event) => node.setIsSelected(true), ɵ6 = /**
 * @param {?} tree
 * @param {?} node
 * @param {?} $event
 * @return {?}
 */
(tree, node, $event) => node.setIsSelected(false), ɵ7 = /**
 * @param {?} tree
 * @param {?} node
 * @param {?} $event
 * @return {?}
 */
(tree, node, $event) => node.focus(), ɵ8 = /**
 * @param {?} tree
 * @param {?} node
 * @param {?} $event
 * @return {?}
 */
(tree, node, $event) => node.hasChildren && node.toggleExpanded(), ɵ9 = /**
 * @param {?} tree
 * @param {?} node
 * @param {?} $event
 * @return {?}
 */
(tree, node, $event) => node.expand(), ɵ10 = /**
 * @param {?} tree
 * @param {?} node
 * @param {?} $event
 * @return {?}
 */
(tree, node, $event) => node.collapse(), ɵ11 = /**
 * @param {?} tree
 * @param {?} node
 * @param {?} $event
 * @return {?}
 */
(tree, node, $event) => tree.focusDrillDown(), ɵ12 = /**
 * @param {?} tree
 * @param {?} node
 * @param {?} $event
 * @return {?}
 */
(tree, node, $event) => tree.focusDrillUp(), ɵ13 = /**
 * @param {?} tree
 * @param {?} node
 * @param {?} $event
 * @return {?}
 */
(tree, node, $event) => tree.focusNextNode(), ɵ14 = /**
 * @param {?} tree
 * @param {?} node
 * @param {?} $event
 * @return {?}
 */
(tree, node, $event) => tree.focusPreviousNode(), ɵ15 = /**
 * @param {?} tree
 * @param {?} node
 * @param {?} $event
 * @param {?} __3
 * @return {?}
 */
(tree, node, $event, { from, to }) => {
    // default action assumes from = node, to = {parent, index}
    if ($event.ctrlKey) {
        tree.copyNode(from, to);
    }
    else {
        tree.moveNode(from, to);
    }
};
/** @type {?} */
const TREE_ACTIONS = {
    TOGGLE_ACTIVE: (ɵ0),
    TOGGLE_ACTIVE_MULTI: (ɵ1),
    TOGGLE_SELECTED: (ɵ2),
    ACTIVATE: (ɵ3),
    DEACTIVATE: (ɵ4),
    SELECT: (ɵ5),
    DESELECT: (ɵ6),
    FOCUS: (ɵ7),
    TOGGLE_EXPANDED: (ɵ8),
    EXPAND: (ɵ9),
    COLLAPSE: (ɵ10),
    DRILL_DOWN: (ɵ11),
    DRILL_UP: (ɵ12),
    NEXT_NODE: (ɵ13),
    PREVIOUS_NODE: (ɵ14),
    MOVE_NODE: (ɵ15)
};
/** @type {?} */
const defaultActionMapping = {
    mouse: {
        click: TREE_ACTIONS.TOGGLE_ACTIVE,
        dblClick: null,
        contextMenu: null,
        expanderClick: TREE_ACTIONS.TOGGLE_EXPANDED,
        checkboxClick: TREE_ACTIONS.TOGGLE_SELECTED,
        drop: TREE_ACTIONS.MOVE_NODE
    },
    keys: {
        [KEYS.RIGHT]: TREE_ACTIONS.DRILL_DOWN,
        [KEYS.LEFT]: TREE_ACTIONS.DRILL_UP,
        [KEYS.DOWN]: TREE_ACTIONS.NEXT_NODE,
        [KEYS.UP]: TREE_ACTIONS.PREVIOUS_NODE,
        [KEYS.SPACE]: TREE_ACTIONS.TOGGLE_ACTIVE,
        [KEYS.ENTER]: TREE_ACTIONS.TOGGLE_ACTIVE
    }
};
/**
 * @record
 */
function IActionMapping() { }
if (false) {
    /** @type {?|undefined} */
    IActionMapping.prototype.mouse;
    /** @type {?|undefined} */
    IActionMapping.prototype.keys;
}
class TreeOptions {
    /**
     * @param {?=} options
     */
    constructor(options = {}) {
        this.options = options;
        this.actionMapping = defaultsDeep({}, this.options.actionMapping, defaultActionMapping);
        if (options.rtl) {
            this.actionMapping.keys[KEYS.RIGHT] = (/** @type {?} */ (get(options, ['actionMapping', 'keys', KEYS.RIGHT]))) || TREE_ACTIONS.DRILL_UP;
            this.actionMapping.keys[KEYS.LEFT] = (/** @type {?} */ (get(options, ['actionMapping', 'keys', KEYS.LEFT]))) || TREE_ACTIONS.DRILL_DOWN;
        }
    }
    /**
     * @return {?}
     */
    get hasChildrenField() { return this.options.hasChildrenField || 'hasChildren'; }
    /**
     * @return {?}
     */
    get childrenField() { return this.options.childrenField || 'children'; }
    /**
     * @return {?}
     */
    get displayField() { return this.options.displayField || 'name'; }
    /**
     * @return {?}
     */
    get idField() { return this.options.idField || 'id'; }
    /**
     * @return {?}
     */
    get isExpandedField() { return this.options.isExpandedField || 'isExpanded'; }
    /**
     * @return {?}
     */
    get getChildren() { return this.options.getChildren; }
    /**
     * @return {?}
     */
    get levelPadding() { return this.options.levelPadding || 0; }
    /**
     * @return {?}
     */
    get useVirtualScroll() { return this.options.useVirtualScroll; }
    /**
     * @return {?}
     */
    get animateExpand() { return this.options.animateExpand; }
    /**
     * @return {?}
     */
    get animateSpeed() { return this.options.animateSpeed || 1; }
    /**
     * @return {?}
     */
    get animateAcceleration() { return this.options.animateAcceleration || 1.2; }
    /**
     * @return {?}
     */
    get scrollOnActivate() { return this.options.scrollOnActivate === undefined ? true : this.options.scrollOnActivate; }
    /**
     * @return {?}
     */
    get rtl() { return !!this.options.rtl; }
    /**
     * @return {?}
     */
    get rootId() { return this.options.rootId; }
    /**
     * @return {?}
     */
    get useCheckbox() { return this.options.useCheckbox; }
    /**
     * @return {?}
     */
    get useTriState() { return this.options.useTriState === undefined ? true : this.options.useTriState; }
    /**
     * @return {?}
     */
    get scrollContainer() { return this.options.scrollContainer; }
    /**
     * @return {?}
     */
    get allowDragoverStyling() { return this.options.allowDragoverStyling === undefined ? true : this.options.allowDragoverStyling; }
    /**
     * @param {?} node
     * @return {?}
     */
    getNodeClone(node) {
        if (this.options.getNodeClone) {
            return this.options.getNodeClone(node);
        }
        return omit(Object.assign({}, node.data), ['id']);
    }
    /**
     * @param {?} element
     * @param {?} to
     * @param {?=} $event
     * @return {?}
     */
    allowDrop(element, to, $event) {
        if (this.options.allowDrop instanceof Function) {
            return this.options.allowDrop(element, to, $event);
        }
        else {
            return this.options.allowDrop === undefined ? true : this.options.allowDrop;
        }
    }
    /**
     * @param {?} node
     * @return {?}
     */
    allowDrag(node) {
        if (this.options.allowDrag instanceof Function) {
            return this.options.allowDrag(node);
        }
        else {
            return this.options.allowDrag;
        }
    }
    /**
     * @param {?} node
     * @return {?}
     */
    nodeClass(node) {
        return this.options.nodeClass ? this.options.nodeClass(node) : '';
    }
    /**
     * @param {?} node
     * @return {?}
     */
    nodeHeight(node) {
        if (node.data.virtual) {
            return 0;
        }
        /** @type {?} */
        let nodeHeight = this.options.nodeHeight || 22;
        if (typeof nodeHeight === 'function') {
            nodeHeight = nodeHeight(node);
        }
        // account for drop slots:
        return nodeHeight + (node.index === 0 ? 2 : 1) * this.dropSlotHeight;
    }
    /**
     * @return {?}
     */
    get dropSlotHeight() {
        return isNumber(this.options.dropSlotHeight) ? this.options.dropSlotHeight : 2;
    }
}
if (false) {
    /** @type {?} */
    TreeOptions.prototype.actionMapping;
    /**
     * @type {?}
     * @private
     */
    TreeOptions.prototype.options;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/constants/events.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const TREE_EVENTS = {
    toggleExpanded: 'toggleExpanded',
    activate: 'activate',
    deactivate: 'deactivate',
    nodeActivate: 'nodeActivate',
    nodeDeactivate: 'nodeDeactivate',
    select: 'select',
    deselect: 'deselect',
    focus: 'focus',
    blur: 'blur',
    initialized: 'initialized',
    updateData: 'updateData',
    moveNode: 'moveNode',
    copyNode: 'copyNode',
    event: 'event',
    loadNodeChildren: 'loadNodeChildren',
    changeFilter: 'changeFilter',
    stateChange: 'stateChange'
};

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
class TreeNode {
    /**
     * @param {?} data
     * @param {?} parent
     * @param {?} treeModel
     * @param {?} index
     */
    constructor(data, parent, treeModel, index) {
        this.data = data;
        this.parent = parent;
        this.treeModel = treeModel;
        this.position = 0;
        this.allowDrop = (/**
         * @param {?} element
         * @param {?=} $event
         * @return {?}
         */
        (element, $event) => {
            return this.options.allowDrop(element, { parent: this, index: 0 }, $event);
        });
        this.allowDragoverStyling = (/**
         * @return {?}
         */
        () => {
            return this.options.allowDragoverStyling;
        });
        if (this.id === undefined || this.id === null) {
            this.id = uuid();
        } // Make sure there's a unique id without overriding existing ids to work with immutable data structures
        this.index = index;
        if (this.getField('children')) {
            this._initChildren();
        }
        this.autoLoadChildren();
    }
    /**
     * @return {?}
     */
    get isHidden() { return this.treeModel.isHidden(this); }
    ;
    /**
     * @return {?}
     */
    get isExpanded() { return this.treeModel.isExpanded(this); }
    ;
    /**
     * @return {?}
     */
    get isActive() { return this.treeModel.isActive(this); }
    ;
    /**
     * @return {?}
     */
    get isFocused() { return this.treeModel.isNodeFocused(this); }
    ;
    /**
     * @return {?}
     */
    get isSelected() {
        if (this.isSelectable()) {
            return this.treeModel.isSelected(this);
        }
        else {
            return some(this.children, (/**
             * @param {?} node
             * @return {?}
             */
            (node) => node.isSelected));
        }
    }
    ;
    /**
     * @return {?}
     */
    get isAllSelected() {
        if (this.isSelectable()) {
            return this.treeModel.isSelected(this);
        }
        else {
            return every(this.children, (/**
             * @param {?} node
             * @return {?}
             */
            (node) => node.isAllSelected));
        }
    }
    ;
    /**
     * @return {?}
     */
    get isPartiallySelected() {
        return this.isSelected && !this.isAllSelected;
    }
    /**
     * @return {?}
     */
    get level() {
        return this.parent ? this.parent.level + 1 : 0;
    }
    /**
     * @return {?}
     */
    get path() {
        return this.parent ? [...this.parent.path, this.id] : [];
    }
    /**
     * @return {?}
     */
    get elementRef() {
        throw `Element Ref is no longer supported since introducing virtual scroll\n
      You may use a template to obtain a reference to the element`;
    }
    /**
     * @return {?}
     */
    get originalNode() { return this._originalNode; }
    ;
    // helper get functions:
    /**
     * @return {?}
     */
    get hasChildren() {
        return !!(this.getField('hasChildren') || (this.children && this.children.length > 0));
    }
    /**
     * @return {?}
     */
    get isCollapsed() { return !this.isExpanded; }
    /**
     * @return {?}
     */
    get isLeaf() { return !this.hasChildren; }
    /**
     * @return {?}
     */
    get isRoot() { return this.parent.data.virtual; }
    /**
     * @return {?}
     */
    get realParent() { return this.isRoot ? null : this.parent; }
    // proxy functions:
    /**
     * @return {?}
     */
    get options() { return this.treeModel.options; }
    /**
     * @param {?} event
     * @return {?}
     */
    fireEvent(event) { this.treeModel.fireEvent(event); }
    // field accessors:
    /**
     * @return {?}
     */
    get displayField() {
        return this.getField('display');
    }
    /**
     * @return {?}
     */
    get id() {
        return this.getField('id');
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set id(value) {
        this.setField('id', value);
    }
    /**
     * @param {?} key
     * @return {?}
     */
    getField(key) {
        return this.data[this.options[`${key}Field`]];
    }
    /**
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    setField(key, value) {
        this.data[this.options[`${key}Field`]] = value;
    }
    // traversing:
    /**
     * @param {?} steps
     * @param {?=} skipHidden
     * @return {?}
     */
    _findAdjacentSibling(steps, skipHidden = false) {
        /** @type {?} */
        const siblings = this._getParentsChildren(skipHidden);
        /** @type {?} */
        const index = siblings.indexOf(this);
        return siblings.length > index + steps ? siblings[index + steps] : null;
    }
    /**
     * @param {?=} skipHidden
     * @return {?}
     */
    findNextSibling(skipHidden = false) {
        return this._findAdjacentSibling(+1, skipHidden);
    }
    /**
     * @param {?=} skipHidden
     * @return {?}
     */
    findPreviousSibling(skipHidden = false) {
        return this._findAdjacentSibling(-1, skipHidden);
    }
    /**
     * @return {?}
     */
    getVisibleChildren() {
        return this.visibleChildren;
    }
    /**
     * @return {?}
     */
    get visibleChildren() {
        return (this.children || []).filter((/**
         * @param {?} node
         * @return {?}
         */
        (node) => !node.isHidden));
    }
    /**
     * @param {?=} skipHidden
     * @return {?}
     */
    getFirstChild(skipHidden = false) {
        /** @type {?} */
        let children = skipHidden ? this.visibleChildren : this.children;
        return first(children || []);
    }
    /**
     * @param {?=} skipHidden
     * @return {?}
     */
    getLastChild(skipHidden = false) {
        /** @type {?} */
        let children = skipHidden ? this.visibleChildren : this.children;
        return last(children || []);
    }
    /**
     * @param {?=} goInside
     * @param {?=} skipHidden
     * @return {?}
     */
    findNextNode(goInside = true, skipHidden = false) {
        return goInside && this.isExpanded && this.getFirstChild(skipHidden) ||
            this.findNextSibling(skipHidden) ||
            this.parent && this.parent.findNextNode(false, skipHidden);
    }
    /**
     * @param {?=} skipHidden
     * @return {?}
     */
    findPreviousNode(skipHidden = false) {
        /** @type {?} */
        let previousSibling = this.findPreviousSibling(skipHidden);
        if (!previousSibling) {
            return this.realParent;
        }
        return previousSibling._getLastOpenDescendant(skipHidden);
    }
    /**
     * @param {?=} skipHidden
     * @return {?}
     */
    _getLastOpenDescendant(skipHidden = false) {
        /** @type {?} */
        const lastChild = this.getLastChild(skipHidden);
        return (this.isCollapsed || !lastChild)
            ? this
            : lastChild._getLastOpenDescendant(skipHidden);
    }
    /**
     * @private
     * @param {?=} skipHidden
     * @return {?}
     */
    _getParentsChildren(skipHidden = false) {
        /** @type {?} */
        const children = this.parent &&
            (skipHidden ? this.parent.getVisibleChildren() : this.parent.children);
        return children || [];
    }
    /**
     * @private
     * @param {?=} skipHidden
     * @return {?}
     */
    getIndexInParent(skipHidden = false) {
        return this._getParentsChildren(skipHidden).indexOf(this);
    }
    /**
     * @param {?} node
     * @return {?}
     */
    isDescendantOf(node) {
        if (this === node)
            return true;
        else
            return this.parent && this.parent.isDescendantOf(node);
    }
    /**
     * @return {?}
     */
    getNodePadding() {
        return this.options.levelPadding * (this.level - 1) + 'px';
    }
    /**
     * @return {?}
     */
    getClass() {
        return [this.options.nodeClass(this), `tree-node-level-${this.level}`].join(' ');
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onDrop($event) {
        this.mouseAction('drop', $event.event, {
            from: $event.element,
            to: { parent: this, index: 0, dropOnNode: true }
        });
    }
    /**
     * @return {?}
     */
    allowDrag() {
        return this.options.allowDrag(this);
    }
    // helper methods:
    /**
     * @return {?}
     */
    loadNodeChildren() {
        if (!this.options.getChildren) {
            return Promise.resolve(); // Not getChildren method - for using redux
        }
        return Promise.resolve(this.options.getChildren(this))
            .then((/**
         * @param {?} children
         * @return {?}
         */
        (children) => {
            if (children) {
                this.setField('children', children);
                this._initChildren();
                if (this.options.useTriState && this.treeModel.isSelected(this)) {
                    this.setIsSelected(true);
                }
                this.children.forEach((/**
                 * @param {?} child
                 * @return {?}
                 */
                (child) => {
                    if (child.getField('isExpanded') && child.hasChildren) {
                        child.expand();
                    }
                }));
            }
        })).then((/**
         * @return {?}
         */
        () => {
            this.fireEvent({
                eventName: TREE_EVENTS.loadNodeChildren,
                node: this
            });
        }));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    expand() {
        if (!(/** @type {?} */ (this)).isExpanded) {
            (/** @type {?} */ (this)).toggleExpanded();
        }
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    collapse() {
        if ((/** @type {?} */ (this)).isExpanded) {
            (/** @type {?} */ (this)).toggleExpanded();
        }
        return (/** @type {?} */ (this));
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    doForAll(fn) {
        Promise.resolve(fn(this)).then((/**
         * @return {?}
         */
        () => {
            if (this.children) {
                this.children.forEach((/**
                 * @param {?} child
                 * @return {?}
                 */
                (child) => child.doForAll(fn)));
            }
        }));
    }
    /**
     * @return {?}
     */
    expandAll() {
        this.doForAll((/**
         * @param {?} node
         * @return {?}
         */
        (node) => node.expand()));
    }
    /**
     * @return {?}
     */
    collapseAll() {
        this.doForAll((/**
         * @param {?} node
         * @return {?}
         */
        (node) => node.collapse()));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    ensureVisible() {
        if ((/** @type {?} */ (this)).realParent) {
            (/** @type {?} */ (this)).realParent.expand();
            (/** @type {?} */ (this)).realParent.ensureVisible();
        }
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    toggleExpanded() {
        (/** @type {?} */ (this)).setIsExpanded(!(/** @type {?} */ (this)).isExpanded);
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} value
     * @return {THIS}
     */
    setIsExpanded(value) {
        if ((/** @type {?} */ (this)).hasChildren) {
            (/** @type {?} */ (this)).treeModel.setExpandedNode((/** @type {?} */ (this)), value);
        }
        return (/** @type {?} */ (this));
    }
    ;
    /**
     * @return {?}
     */
    autoLoadChildren() {
        this.handler =
            reaction((/**
             * @return {?}
             */
            () => this.isExpanded), (/**
             * @param {?} isExpanded
             * @return {?}
             */
            (isExpanded) => {
                if (!this.children && this.hasChildren && isExpanded) {
                    this.loadNodeChildren();
                }
            }), { fireImmediately: true });
    }
    /**
     * @return {?}
     */
    dispose() {
        if (this.children) {
            this.children.forEach((/**
             * @param {?} child
             * @return {?}
             */
            (child) => child.dispose()));
        }
        if (this.handler) {
            this.handler();
        }
        this.parent = null;
        this.children = null;
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} value
     * @param {?=} multi
     * @return {THIS}
     */
    setIsActive(value, multi = false) {
        (/** @type {?} */ (this)).treeModel.setActiveNode((/** @type {?} */ (this)), value, multi);
        if (value) {
            (/** @type {?} */ (this)).focus((/** @type {?} */ (this)).options.scrollOnActivate);
        }
        return (/** @type {?} */ (this));
    }
    /**
     * @return {?}
     */
    isSelectable() {
        return this.isLeaf || !this.children || !this.options.useTriState;
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} value
     * @return {THIS}
     */
    setIsSelected(value) {
        if ((/** @type {?} */ (this)).isSelectable()) {
            (/** @type {?} */ (this)).treeModel.setSelectedNode((/** @type {?} */ (this)), value);
        }
        else {
            (/** @type {?} */ (this)).visibleChildren.forEach((/**
             * @param {?} child
             * @return {?}
             */
            (child) => child.setIsSelected(value)));
        }
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    toggleSelected() {
        (/** @type {?} */ (this)).setIsSelected(!(/** @type {?} */ (this)).isSelected);
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?=} multi
     * @return {THIS}
     */
    toggleActivated(multi = false) {
        (/** @type {?} */ (this)).setIsActive(!(/** @type {?} */ (this)).isActive, multi);
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?=} multi
     * @return {THIS}
     */
    setActiveAndVisible(multi = false) {
        (/** @type {?} */ (this)).setIsActive(true, multi)
            .ensureVisible();
        setTimeout((/** @type {?} */ (this)).scrollIntoView.bind((/** @type {?} */ (this))));
        return (/** @type {?} */ (this));
    }
    /**
     * @param {?=} force
     * @return {?}
     */
    scrollIntoView(force = false) {
        this.treeModel.virtualScroll.scrollIntoView(this, force);
    }
    /**
     * @template THIS
     * @this {THIS}
     * @param {?=} scroll
     * @return {THIS}
     */
    focus(scroll = true) {
        /** @type {?} */
        let previousNode = (/** @type {?} */ (this)).treeModel.getFocusedNode();
        (/** @type {?} */ (this)).treeModel.setFocusedNode((/** @type {?} */ (this)));
        if (scroll) {
            (/** @type {?} */ (this)).scrollIntoView();
        }
        if (previousNode) {
            (/** @type {?} */ (this)).fireEvent({ eventName: TREE_EVENTS.blur, node: previousNode });
        }
        (/** @type {?} */ (this)).fireEvent({ eventName: TREE_EVENTS.focus, node: (/** @type {?} */ (this)) });
        return (/** @type {?} */ (this));
    }
    /**
     * @template THIS
     * @this {THIS}
     * @return {THIS}
     */
    blur() {
        /** @type {?} */
        let previousNode = (/** @type {?} */ (this)).treeModel.getFocusedNode();
        (/** @type {?} */ (this)).treeModel.setFocusedNode(null);
        if (previousNode) {
            (/** @type {?} */ (this)).fireEvent({ eventName: TREE_EVENTS.blur, node: (/** @type {?} */ (this)) });
        }
        return (/** @type {?} */ (this));
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setIsHidden(value) {
        this.treeModel.setIsHidden(this, value);
    }
    /**
     * @return {?}
     */
    hide() {
        this.setIsHidden(true);
    }
    /**
     * @return {?}
     */
    show() {
        this.setIsHidden(false);
    }
    /**
     * @param {?} actionName
     * @param {?} $event
     * @param {?=} data
     * @return {?}
     */
    mouseAction(actionName, $event, data = null) {
        this.treeModel.setFocus(true);
        /** @type {?} */
        const actionMapping = this.options.actionMapping.mouse;
        /** @type {?} */
        const mouseAction = actionMapping[actionName];
        if (mouseAction) {
            mouseAction(this.treeModel, this, $event, data);
        }
    }
    /**
     * @return {?}
     */
    getSelfHeight() {
        return this.options.nodeHeight(this);
    }
    /**
     * @return {?}
     */
    _initChildren() {
        this.children = this.getField('children')
            .map((/**
         * @param {?} c
         * @param {?} index
         * @return {?}
         */
        (c, index) => new TreeNode(c, this, this.treeModel, index)));
    }
}
__decorate([
    computed$1,
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], TreeNode.prototype, "isHidden", null);
__decorate([
    computed$1,
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], TreeNode.prototype, "isExpanded", null);
__decorate([
    computed$1,
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], TreeNode.prototype, "isActive", null);
__decorate([
    computed$1,
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], TreeNode.prototype, "isFocused", null);
__decorate([
    computed$1,
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], TreeNode.prototype, "isSelected", null);
__decorate([
    computed$1,
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], TreeNode.prototype, "isAllSelected", null);
__decorate([
    computed$1,
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], TreeNode.prototype, "isPartiallySelected", null);
__decorate([
    observable$1,
    __metadata("design:type", Array)
], TreeNode.prototype, "children", void 0);
__decorate([
    observable$1,
    __metadata("design:type", Number)
], TreeNode.prototype, "index", void 0);
__decorate([
    observable$1,
    __metadata("design:type", Object)
], TreeNode.prototype, "position", void 0);
__decorate([
    observable$1,
    __metadata("design:type", Number)
], TreeNode.prototype, "height", void 0);
__decorate([
    computed$1,
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [])
], TreeNode.prototype, "level", null);
__decorate([
    computed$1,
    __metadata("design:type", Array),
    __metadata("design:paramtypes", [])
], TreeNode.prototype, "path", null);
__decorate([
    computed$1,
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], TreeNode.prototype, "visibleChildren", null);
__decorate([
    action$1,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], TreeNode.prototype, "setIsSelected", null);
__decorate([
    action$1,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], TreeNode.prototype, "_initChildren", null);
if (false) {
    /**
     * @type {?}
     * @private
     */
    TreeNode.prototype.handler;
    /** @type {?} */
    TreeNode.prototype.children;
    /** @type {?} */
    TreeNode.prototype.index;
    /** @type {?} */
    TreeNode.prototype.position;
    /** @type {?} */
    TreeNode.prototype.height;
    /**
     * @type {?}
     * @private
     */
    TreeNode.prototype._originalNode;
    /** @type {?} */
    TreeNode.prototype.allowDrop;
    /** @type {?} */
    TreeNode.prototype.allowDragoverStyling;
    /** @type {?} */
    TreeNode.prototype.data;
    /** @type {?} */
    TreeNode.prototype.parent;
    /** @type {?} */
    TreeNode.prototype.treeModel;
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
}
/**
 * @return {?}
 */
function uuid() {
    return Math.floor(Math.random() * 10000000000000);
}

var __decorate$1 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$1 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
class TreeModel {
    constructor() {
        this.options = new TreeOptions();
        this.eventNames = Object.keys(TREE_EVENTS);
        this.expandedNodeIds = {};
        this.selectedLeafNodeIds = {};
        this.activeNodeIds = {};
        this.hiddenNodeIds = {};
        this.focusedNodeId = null;
        this.firstUpdate = true;
        this.subscriptions = [];
    }
    // events
    /**
     * @param {?} event
     * @return {?}
     */
    fireEvent(event) {
        event.treeModel = this;
        this.events[event.eventName].emit(event);
        this.events.event.emit(event);
    }
    /**
     * @param {?} eventName
     * @param {?} fn
     * @return {?}
     */
    subscribe(eventName, fn) {
        /** @type {?} */
        const subscription = this.events[eventName].subscribe(fn);
        this.subscriptions.push(subscription);
    }
    // getters
    /**
     * @return {?}
     */
    getFocusedNode() {
        return this.focusedNode;
    }
    /**
     * @return {?}
     */
    getActiveNode() {
        return this.activeNodes[0];
    }
    /**
     * @return {?}
     */
    getActiveNodes() {
        return this.activeNodes;
    }
    /**
     * @return {?}
     */
    getVisibleRoots() {
        return this.virtualRoot.visibleChildren;
    }
    /**
     * @param {?=} skipHidden
     * @return {?}
     */
    getFirstRoot(skipHidden = false) {
        return first(skipHidden ? this.getVisibleRoots() : this.roots);
    }
    /**
     * @param {?=} skipHidden
     * @return {?}
     */
    getLastRoot(skipHidden = false) {
        return last(skipHidden ? this.getVisibleRoots() : this.roots);
    }
    /**
     * @return {?}
     */
    get isFocused() {
        return TreeModel.focusedTree === this;
    }
    /**
     * @param {?} node
     * @return {?}
     */
    isNodeFocused(node) {
        return this.focusedNode === node;
    }
    /**
     * @return {?}
     */
    isEmptyTree() {
        return this.roots && this.roots.length === 0;
    }
    /**
     * @return {?}
     */
    get focusedNode() {
        return this.focusedNodeId ? this.getNodeById(this.focusedNodeId) : null;
    }
    /**
     * @return {?}
     */
    get expandedNodes() {
        /** @type {?} */
        const nodes = Object.keys(this.expandedNodeIds)
            .filter((/**
         * @param {?} id
         * @return {?}
         */
        (id) => this.expandedNodeIds[id]))
            .map((/**
         * @param {?} id
         * @return {?}
         */
        (id) => this.getNodeById(id)));
        return compact(nodes);
    }
    /**
     * @return {?}
     */
    get activeNodes() {
        /** @type {?} */
        const nodes = Object.keys(this.activeNodeIds)
            .filter((/**
         * @param {?} id
         * @return {?}
         */
        (id) => this.activeNodeIds[id]))
            .map((/**
         * @param {?} id
         * @return {?}
         */
        (id) => this.getNodeById(id)));
        return compact(nodes);
    }
    /**
     * @return {?}
     */
    get hiddenNodes() {
        /** @type {?} */
        const nodes = Object.keys(this.hiddenNodeIds)
            .filter((/**
         * @param {?} id
         * @return {?}
         */
        (id) => this.hiddenNodeIds[id]))
            .map((/**
         * @param {?} id
         * @return {?}
         */
        (id) => this.getNodeById(id)));
        return compact(nodes);
    }
    /**
     * @return {?}
     */
    get selectedLeafNodes() {
        /** @type {?} */
        const nodes = Object.keys(this.selectedLeafNodeIds)
            .filter((/**
         * @param {?} id
         * @return {?}
         */
        (id) => this.selectedLeafNodeIds[id]))
            .map((/**
         * @param {?} id
         * @return {?}
         */
        (id) => this.getNodeById(id)));
        return compact(nodes);
    }
    // locating nodes
    /**
     * @param {?} path
     * @param {?=} startNode
     * @return {?}
     */
    getNodeByPath(path, startNode = null) {
        if (!path)
            return null;
        startNode = startNode || this.virtualRoot;
        if (path.length === 0)
            return startNode;
        if (!startNode.children)
            return null;
        /** @type {?} */
        const childId = path.shift();
        /** @type {?} */
        const childNode = find(startNode.children, { id: childId });
        if (!childNode)
            return null;
        return this.getNodeByPath(path, childNode);
    }
    /**
     * @param {?} id
     * @return {?}
     */
    getNodeById(id) {
        /** @type {?} */
        const idStr = id.toString();
        return this.getNodeBy((/**
         * @param {?} node
         * @return {?}
         */
        (node) => node.id.toString() === idStr));
    }
    /**
     * @param {?} predicate
     * @param {?=} startNode
     * @return {?}
     */
    getNodeBy(predicate, startNode = null) {
        startNode = startNode || this.virtualRoot;
        if (!startNode.children)
            return null;
        /** @type {?} */
        const found = find(startNode.children, predicate);
        if (found) { // found in children
            return found;
        }
        else { // look in children's children
            for (let child of startNode.children) {
                /** @type {?} */
                const foundInChildren = this.getNodeBy(predicate, child);
                if (foundInChildren)
                    return foundInChildren;
            }
        }
    }
    /**
     * @param {?} node
     * @return {?}
     */
    isExpanded(node) {
        return this.expandedNodeIds[node.id];
    }
    /**
     * @param {?} node
     * @return {?}
     */
    isHidden(node) {
        return this.hiddenNodeIds[node.id];
    }
    /**
     * @param {?} node
     * @return {?}
     */
    isActive(node) {
        return this.activeNodeIds[node.id];
    }
    /**
     * @param {?} node
     * @return {?}
     */
    isSelected(node) {
        return this.selectedLeafNodeIds[node.id];
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.dispose();
        this.unsubscribeAll();
    }
    /**
     * @return {?}
     */
    dispose() {
        // Dispose reactions of the replaced nodes
        if (this.virtualRoot) {
            this.virtualRoot.dispose();
        }
    }
    /**
     * @return {?}
     */
    unsubscribeAll() {
        this.subscriptions.forEach((/**
         * @param {?} subscription
         * @return {?}
         */
        subscription => subscription.unsubscribe()));
        this.subscriptions = [];
    }
    // actions
    /**
     * @param {?} __0
     * @return {?}
     */
    setData({ nodes, options = null, events = null }) {
        if (options) {
            this.options = new TreeOptions(options);
        }
        if (events) {
            this.events = events;
        }
        if (nodes) {
            this.nodes = nodes;
        }
        this.update();
    }
    /**
     * @return {?}
     */
    update() {
        // Rebuild tree:
        /** @type {?} */
        let virtualRootConfig = {
            id: this.options.rootId,
            virtual: true,
            [this.options.childrenField]: this.nodes
        };
        this.dispose();
        this.virtualRoot = new TreeNode(virtualRootConfig, null, this, 0);
        this.roots = this.virtualRoot.children;
        // Fire event:
        if (this.firstUpdate) {
            if (this.roots) {
                this.firstUpdate = false;
                this._calculateExpandedNodes();
            }
        }
        else {
            this.fireEvent({ eventName: TREE_EVENTS.updateData });
        }
    }
    /**
     * @param {?} node
     * @return {?}
     */
    setFocusedNode(node) {
        this.focusedNodeId = node ? node.id : null;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setFocus(value) {
        TreeModel.focusedTree = value ? this : null;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    doForAll(fn) {
        this.roots.forEach((/**
         * @param {?} root
         * @return {?}
         */
        (root) => root.doForAll(fn)));
    }
    /**
     * @return {?}
     */
    focusNextNode() {
        /** @type {?} */
        let previousNode = this.getFocusedNode();
        /** @type {?} */
        let nextNode = previousNode ? previousNode.findNextNode(true, true) : this.getFirstRoot(true);
        if (nextNode)
            nextNode.focus();
    }
    /**
     * @return {?}
     */
    focusPreviousNode() {
        /** @type {?} */
        let previousNode = this.getFocusedNode();
        /** @type {?} */
        let nextNode = previousNode ? previousNode.findPreviousNode(true) : this.getLastRoot(true);
        if (nextNode)
            nextNode.focus();
    }
    /**
     * @return {?}
     */
    focusDrillDown() {
        /** @type {?} */
        let previousNode = this.getFocusedNode();
        if (previousNode && previousNode.isCollapsed && previousNode.hasChildren) {
            previousNode.toggleExpanded();
        }
        else {
            /** @type {?} */
            let nextNode = previousNode ? previousNode.getFirstChild(true) : this.getFirstRoot(true);
            if (nextNode)
                nextNode.focus();
        }
    }
    /**
     * @return {?}
     */
    focusDrillUp() {
        /** @type {?} */
        let previousNode = this.getFocusedNode();
        if (!previousNode)
            return;
        if (previousNode.isExpanded) {
            previousNode.toggleExpanded();
        }
        else {
            /** @type {?} */
            let nextNode = previousNode.realParent;
            if (nextNode)
                nextNode.focus();
        }
    }
    /**
     * @param {?} node
     * @param {?} value
     * @param {?=} multi
     * @return {?}
     */
    setActiveNode(node, value, multi = false) {
        if (multi) {
            this._setActiveNodeMulti(node, value);
        }
        else {
            this._setActiveNodeSingle(node, value);
        }
        if (value) {
            node.focus(this.options.scrollOnActivate);
            this.fireEvent({ eventName: TREE_EVENTS.activate, node });
            this.fireEvent({ eventName: TREE_EVENTS.nodeActivate, node }); // For IE11
        }
        else {
            this.fireEvent({ eventName: TREE_EVENTS.deactivate, node });
            this.fireEvent({ eventName: TREE_EVENTS.nodeDeactivate, node }); // For IE11
        }
    }
    /**
     * @param {?} node
     * @param {?} value
     * @return {?}
     */
    setSelectedNode(node, value) {
        this.selectedLeafNodeIds = Object.assign({}, this.selectedLeafNodeIds, { [node.id]: value });
        if (value) {
            node.focus();
            this.fireEvent({ eventName: TREE_EVENTS.select, node });
        }
        else {
            this.fireEvent({ eventName: TREE_EVENTS.deselect, node });
        }
    }
    /**
     * @param {?} node
     * @param {?} value
     * @return {?}
     */
    setExpandedNode(node, value) {
        this.expandedNodeIds = Object.assign({}, this.expandedNodeIds, { [node.id]: value });
        this.fireEvent({ eventName: TREE_EVENTS.toggleExpanded, node, isExpanded: value });
    }
    /**
     * @return {?}
     */
    expandAll() {
        this.roots.forEach((/**
         * @param {?} root
         * @return {?}
         */
        (root) => root.expandAll()));
    }
    /**
     * @return {?}
     */
    collapseAll() {
        this.roots.forEach((/**
         * @param {?} root
         * @return {?}
         */
        (root) => root.collapseAll()));
    }
    /**
     * @param {?} node
     * @param {?} value
     * @return {?}
     */
    setIsHidden(node, value) {
        this.hiddenNodeIds = Object.assign({}, this.hiddenNodeIds, { [node.id]: value });
    }
    /**
     * @param {?} nodeIds
     * @return {?}
     */
    setHiddenNodeIds(nodeIds) {
        this.hiddenNodeIds = nodeIds.reduce((/**
         * @param {?} hiddenNodeIds
         * @param {?} id
         * @return {?}
         */
        (hiddenNodeIds, id) => Object.assign(hiddenNodeIds, {
            [id]: true
        })), {});
    }
    /**
     * @param {?} node
     * @param {?} $event
     * @return {?}
     */
    performKeyAction(node, $event) {
        /** @type {?} */
        const keyAction = this.options.actionMapping.keys[$event.keyCode];
        if (keyAction) {
            $event.preventDefault();
            keyAction(this, node, $event);
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * @param {?} filter
     * @param {?=} autoShow
     * @return {?}
     */
    filterNodes(filter, autoShow = true) {
        /** @type {?} */
        let filterFn;
        if (!filter) {
            return this.clearFilter();
        }
        // support function and string filter
        if (isString(filter)) {
            filterFn = (/**
             * @param {?} node
             * @return {?}
             */
            (node) => node.displayField.toLowerCase().indexOf(filter.toLowerCase()) !== -1);
        }
        else if (isFunction(filter)) {
            filterFn = filter;
        }
        else {
            console.error('Don\'t know what to do with filter', filter);
            console.error('Should be either a string or function');
            return;
        }
        /** @type {?} */
        const ids = {};
        this.roots.forEach((/**
         * @param {?} node
         * @return {?}
         */
        (node) => this._filterNode(ids, node, filterFn, autoShow)));
        this.hiddenNodeIds = ids;
        this.fireEvent({ eventName: TREE_EVENTS.changeFilter });
    }
    /**
     * @return {?}
     */
    clearFilter() {
        this.hiddenNodeIds = {};
        this.fireEvent({ eventName: TREE_EVENTS.changeFilter });
    }
    /**
     * @param {?} node
     * @param {?} to
     * @return {?}
     */
    moveNode(node, to) {
        /** @type {?} */
        const fromIndex = node.getIndexInParent();
        /** @type {?} */
        const fromParent = node.parent;
        if (!this.canMoveNode(node, to, fromIndex))
            return;
        /** @type {?} */
        const fromChildren = fromParent.getField('children');
        // If node doesn't have children - create children array
        if (!to.parent.getField('children')) {
            to.parent.setField('children', []);
        }
        /** @type {?} */
        const toChildren = to.parent.getField('children');
        /** @type {?} */
        const originalNode = fromChildren.splice(fromIndex, 1)[0];
        // Compensate for index if already removed from parent:
        /** @type {?} */
        let toIndex = (fromParent === to.parent && to.index > fromIndex) ? to.index - 1 : to.index;
        toChildren.splice(toIndex, 0, originalNode);
        fromParent.treeModel.update();
        if (to.parent.treeModel !== fromParent.treeModel) {
            to.parent.treeModel.update();
        }
        this.fireEvent({
            eventName: TREE_EVENTS.moveNode,
            node: originalNode,
            to: { parent: to.parent.data, index: toIndex },
            from: { parent: fromParent.data, index: fromIndex }
        });
    }
    /**
     * @param {?} node
     * @param {?} to
     * @return {?}
     */
    copyNode(node, to) {
        /** @type {?} */
        const fromIndex = node.getIndexInParent();
        if (!this.canMoveNode(node, to, fromIndex))
            return;
        // If node doesn't have children - create children array
        if (!to.parent.getField('children')) {
            to.parent.setField('children', []);
        }
        /** @type {?} */
        const toChildren = to.parent.getField('children');
        /** @type {?} */
        const nodeCopy = this.options.getNodeClone(node);
        toChildren.splice(to.index, 0, nodeCopy);
        node.treeModel.update();
        if (to.parent.treeModel !== node.treeModel) {
            to.parent.treeModel.update();
        }
        this.fireEvent({ eventName: TREE_EVENTS.copyNode, node: nodeCopy, to: { parent: to.parent.data, index: to.index } });
    }
    /**
     * @return {?}
     */
    getState() {
        return {
            expandedNodeIds: this.expandedNodeIds,
            selectedLeafNodeIds: this.selectedLeafNodeIds,
            activeNodeIds: this.activeNodeIds,
            hiddenNodeIds: this.hiddenNodeIds,
            focusedNodeId: this.focusedNodeId
        };
    }
    /**
     * @param {?} state
     * @return {?}
     */
    setState(state) {
        if (!state)
            return;
        Object.assign(this, {
            expandedNodeIds: state.expandedNodeIds || {},
            selectedLeafNodeIds: state.selectedLeafNodeIds || {},
            activeNodeIds: state.activeNodeIds || {},
            hiddenNodeIds: state.hiddenNodeIds || {},
            focusedNodeId: state.focusedNodeId
        });
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    subscribeToState(fn) {
        autorun((/**
         * @return {?}
         */
        () => fn(this.getState())));
    }
    /**
     * @param {?} node
     * @param {?} to
     * @param {?=} fromIndex
     * @return {?}
     */
    canMoveNode(node, to, fromIndex = undefined) {
        /** @type {?} */
        const fromNodeIndex = fromIndex || node.getIndexInParent();
        // same node:
        if (node.parent === to.parent && fromIndex === to.index) {
            return false;
        }
        return !to.parent.isDescendantOf(node);
    }
    /**
     * @return {?}
     */
    calculateExpandedNodes() {
        this._calculateExpandedNodes();
    }
    // private methods
    /**
     * @private
     * @param {?} ids
     * @param {?} node
     * @param {?} filterFn
     * @param {?} autoShow
     * @return {?}
     */
    _filterNode(ids, node, filterFn, autoShow) {
        // if node passes function then it's visible
        /** @type {?} */
        let isVisible = filterFn(node);
        if (node.children) {
            // if one of node's children passes filter then this node is also visible
            node.children.forEach((/**
             * @param {?} child
             * @return {?}
             */
            (child) => {
                if (this._filterNode(ids, child, filterFn, autoShow)) {
                    isVisible = true;
                }
            }));
        }
        // mark node as hidden
        if (!isVisible) {
            ids[node.id] = true;
        }
        // auto expand parents to make sure the filtered nodes are visible
        if (autoShow && isVisible) {
            node.ensureVisible();
        }
        return isVisible;
    }
    /**
     * @private
     * @param {?=} startNode
     * @return {?}
     */
    _calculateExpandedNodes(startNode = null) {
        startNode = startNode || this.virtualRoot;
        if (startNode.data[this.options.isExpandedField]) {
            this.expandedNodeIds = Object.assign({}, this.expandedNodeIds, { [startNode.id]: true });
        }
        if (startNode.children) {
            startNode.children.forEach((/**
             * @param {?} child
             * @return {?}
             */
            (child) => this._calculateExpandedNodes(child)));
        }
    }
    /**
     * @private
     * @param {?} node
     * @param {?} value
     * @return {?}
     */
    _setActiveNodeSingle(node, value) {
        // Deactivate all other nodes:
        this.activeNodes
            .filter((/**
         * @param {?} activeNode
         * @return {?}
         */
        (activeNode) => activeNode !== node))
            .forEach((/**
         * @param {?} activeNode
         * @return {?}
         */
        (activeNode) => {
            this.fireEvent({ eventName: TREE_EVENTS.deactivate, node: activeNode });
            this.fireEvent({ eventName: TREE_EVENTS.nodeDeactivate, node: activeNode }); // For IE11
        }));
        if (value) {
            this.activeNodeIds = { [node.id]: true };
        }
        else {
            this.activeNodeIds = {};
        }
    }
    /**
     * @private
     * @param {?} node
     * @param {?} value
     * @return {?}
     */
    _setActiveNodeMulti(node, value) {
        this.activeNodeIds = Object.assign({}, this.activeNodeIds, { [node.id]: value });
    }
}
TreeModel.focusedTree = null;
TreeModel.decorators = [
    { type: Injectable }
];
__decorate$1([
    observable$1,
    __metadata$1("design:type", Array)
], TreeModel.prototype, "roots", void 0);
__decorate$1([
    observable$1,
    __metadata$1("design:type", Object)
], TreeModel.prototype, "expandedNodeIds", void 0);
__decorate$1([
    observable$1,
    __metadata$1("design:type", Object)
], TreeModel.prototype, "selectedLeafNodeIds", void 0);
__decorate$1([
    observable$1,
    __metadata$1("design:type", Object)
], TreeModel.prototype, "activeNodeIds", void 0);
__decorate$1([
    observable$1,
    __metadata$1("design:type", Object)
], TreeModel.prototype, "hiddenNodeIds", void 0);
__decorate$1([
    observable$1,
    __metadata$1("design:type", Object)
], TreeModel.prototype, "focusedNodeId", void 0);
__decorate$1([
    observable$1,
    __metadata$1("design:type", TreeNode)
], TreeModel.prototype, "virtualRoot", void 0);
__decorate$1([
    computed$1,
    __metadata$1("design:type", Object),
    __metadata$1("design:paramtypes", [])
], TreeModel.prototype, "focusedNode", null);
__decorate$1([
    computed$1,
    __metadata$1("design:type", Object),
    __metadata$1("design:paramtypes", [])
], TreeModel.prototype, "expandedNodes", null);
__decorate$1([
    computed$1,
    __metadata$1("design:type", Object),
    __metadata$1("design:paramtypes", [])
], TreeModel.prototype, "activeNodes", null);
__decorate$1([
    computed$1,
    __metadata$1("design:type", Object),
    __metadata$1("design:paramtypes", [])
], TreeModel.prototype, "hiddenNodes", null);
__decorate$1([
    computed$1,
    __metadata$1("design:type", Object),
    __metadata$1("design:paramtypes", [])
], TreeModel.prototype, "selectedLeafNodes", null);
__decorate$1([
    action$1,
    __metadata$1("design:type", Function),
    __metadata$1("design:paramtypes", [Object]),
    __metadata$1("design:returntype", void 0)
], TreeModel.prototype, "setData", null);
__decorate$1([
    action$1,
    __metadata$1("design:type", Function),
    __metadata$1("design:paramtypes", []),
    __metadata$1("design:returntype", void 0)
], TreeModel.prototype, "update", null);
__decorate$1([
    action$1,
    __metadata$1("design:type", Function),
    __metadata$1("design:paramtypes", [Object]),
    __metadata$1("design:returntype", void 0)
], TreeModel.prototype, "setFocusedNode", null);
__decorate$1([
    action$1,
    __metadata$1("design:type", Function),
    __metadata$1("design:paramtypes", [Object]),
    __metadata$1("design:returntype", void 0)
], TreeModel.prototype, "setFocus", null);
__decorate$1([
    action$1,
    __metadata$1("design:type", Function),
    __metadata$1("design:paramtypes", [Object]),
    __metadata$1("design:returntype", void 0)
], TreeModel.prototype, "doForAll", null);
__decorate$1([
    action$1,
    __metadata$1("design:type", Function),
    __metadata$1("design:paramtypes", []),
    __metadata$1("design:returntype", void 0)
], TreeModel.prototype, "focusNextNode", null);
__decorate$1([
    action$1,
    __metadata$1("design:type", Function),
    __metadata$1("design:paramtypes", []),
    __metadata$1("design:returntype", void 0)
], TreeModel.prototype, "focusPreviousNode", null);
__decorate$1([
    action$1,
    __metadata$1("design:type", Function),
    __metadata$1("design:paramtypes", []),
    __metadata$1("design:returntype", void 0)
], TreeModel.prototype, "focusDrillDown", null);
__decorate$1([
    action$1,
    __metadata$1("design:type", Function),
    __metadata$1("design:paramtypes", []),
    __metadata$1("design:returntype", void 0)
], TreeModel.prototype, "focusDrillUp", null);
__decorate$1([
    action$1,
    __metadata$1("design:type", Function),
    __metadata$1("design:paramtypes", [Object, Object, Object]),
    __metadata$1("design:returntype", void 0)
], TreeModel.prototype, "setActiveNode", null);
__decorate$1([
    action$1,
    __metadata$1("design:type", Function),
    __metadata$1("design:paramtypes", [Object, Object]),
    __metadata$1("design:returntype", void 0)
], TreeModel.prototype, "setSelectedNode", null);
__decorate$1([
    action$1,
    __metadata$1("design:type", Function),
    __metadata$1("design:paramtypes", [Object, Object]),
    __metadata$1("design:returntype", void 0)
], TreeModel.prototype, "setExpandedNode", null);
__decorate$1([
    action$1,
    __metadata$1("design:type", Function),
    __metadata$1("design:paramtypes", []),
    __metadata$1("design:returntype", void 0)
], TreeModel.prototype, "expandAll", null);
__decorate$1([
    action$1,
    __metadata$1("design:type", Function),
    __metadata$1("design:paramtypes", []),
    __metadata$1("design:returntype", void 0)
], TreeModel.prototype, "collapseAll", null);
__decorate$1([
    action$1,
    __metadata$1("design:type", Function),
    __metadata$1("design:paramtypes", [Object, Object]),
    __metadata$1("design:returntype", void 0)
], TreeModel.prototype, "setIsHidden", null);
__decorate$1([
    action$1,
    __metadata$1("design:type", Function),
    __metadata$1("design:paramtypes", [Object]),
    __metadata$1("design:returntype", void 0)
], TreeModel.prototype, "setHiddenNodeIds", null);
__decorate$1([
    action$1,
    __metadata$1("design:type", Function),
    __metadata$1("design:paramtypes", [Object, Object]),
    __metadata$1("design:returntype", void 0)
], TreeModel.prototype, "filterNodes", null);
__decorate$1([
    action$1,
    __metadata$1("design:type", Function),
    __metadata$1("design:paramtypes", []),
    __metadata$1("design:returntype", void 0)
], TreeModel.prototype, "clearFilter", null);
__decorate$1([
    action$1,
    __metadata$1("design:type", Function),
    __metadata$1("design:paramtypes", [Object, Object]),
    __metadata$1("design:returntype", void 0)
], TreeModel.prototype, "moveNode", null);
__decorate$1([
    action$1,
    __metadata$1("design:type", Function),
    __metadata$1("design:paramtypes", [Object, Object]),
    __metadata$1("design:returntype", void 0)
], TreeModel.prototype, "copyNode", null);
__decorate$1([
    action$1,
    __metadata$1("design:type", Function),
    __metadata$1("design:paramtypes", [Object]),
    __metadata$1("design:returntype", void 0)
], TreeModel.prototype, "setState", null);
if (false) {
    /** @type {?} */
    TreeModel.focusedTree;
    /** @type {?} */
    TreeModel.prototype.options;
    /** @type {?} */
    TreeModel.prototype.nodes;
    /** @type {?} */
    TreeModel.prototype.eventNames;
    /** @type {?} */
    TreeModel.prototype.virtualScroll;
    /** @type {?} */
    TreeModel.prototype.roots;
    /** @type {?} */
    TreeModel.prototype.expandedNodeIds;
    /** @type {?} */
    TreeModel.prototype.selectedLeafNodeIds;
    /** @type {?} */
    TreeModel.prototype.activeNodeIds;
    /** @type {?} */
    TreeModel.prototype.hiddenNodeIds;
    /** @type {?} */
    TreeModel.prototype.focusedNodeId;
    /** @type {?} */
    TreeModel.prototype.virtualRoot;
    /**
     * @type {?}
     * @private
     */
    TreeModel.prototype.firstUpdate;
    /**
     * @type {?}
     * @private
     */
    TreeModel.prototype.events;
    /**
     * @type {?}
     * @private
     */
    TreeModel.prototype.subscriptions;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/models/tree-dragged-element.model.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TreeDraggedElement {
    constructor() {
        this._draggedElement = null;
    }
    /**
     * @param {?} draggedElement
     * @return {?}
     */
    set(draggedElement) {
        this._draggedElement = draggedElement;
    }
    /**
     * @return {?}
     */
    get() {
        return this._draggedElement;
    }
    /**
     * @return {?}
     */
    isDragging() {
        return !!this.get();
    }
}
TreeDraggedElement.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ TreeDraggedElement.ɵprov = ɵɵdefineInjectable({ factory: function TreeDraggedElement_Factory() { return new TreeDraggedElement(); }, token: TreeDraggedElement, providedIn: "root" });
if (false) {
    /** @type {?} */
    TreeDraggedElement.prototype._draggedElement;
}

var __decorate$2 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$2 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/** @type {?} */
const Y_OFFSET = 500;
// Extra pixels outside the viewport, in each direction, to render nodes in
/** @type {?} */
const Y_EPSILON = 150;
// Minimum pixel change required to recalculate the rendered nodes
class TreeVirtualScroll {
    /**
     * @param {?} treeModel
     */
    constructor(treeModel) {
        this.treeModel = treeModel;
        this.yBlocks = 0;
        this.x = 0;
        this.viewportHeight = null;
        this.viewport = null;
        treeModel.virtualScroll = this;
        this._dispose = [autorun((/**
             * @return {?}
             */
            () => this.fixScroll()))];
    }
    /**
     * @return {?}
     */
    get y() {
        return this.yBlocks * Y_EPSILON;
    }
    /**
     * @return {?}
     */
    get totalHeight() {
        return this.treeModel.virtualRoot ? this.treeModel.virtualRoot.height : 0;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    fireEvent(event) {
        this.treeModel.fireEvent(event);
    }
    /**
     * @return {?}
     */
    init() {
        /** @type {?} */
        const fn = this.recalcPositions.bind(this);
        fn();
        this._dispose = [
            ...this._dispose,
            reaction((/**
             * @return {?}
             */
            () => this.treeModel.roots), fn),
            reaction((/**
             * @return {?}
             */
            () => this.treeModel.expandedNodeIds), fn),
            reaction((/**
             * @return {?}
             */
            () => this.treeModel.hiddenNodeIds), fn)
        ];
        this.treeModel.subscribe(TREE_EVENTS.loadNodeChildren, fn);
    }
    /**
     * @return {?}
     */
    isEnabled() {
        return this.treeModel.options.useVirtualScroll;
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    _setYBlocks(value) {
        this.yBlocks = value;
    }
    /**
     * @return {?}
     */
    recalcPositions() {
        this.treeModel.virtualRoot.height = this._getPositionAfter(this.treeModel.getVisibleRoots(), 0);
    }
    /**
     * @private
     * @param {?} nodes
     * @param {?} startPos
     * @return {?}
     */
    _getPositionAfter(nodes, startPos) {
        /** @type {?} */
        let position = startPos;
        nodes.forEach((/**
         * @param {?} node
         * @return {?}
         */
        (node) => {
            node.position = position;
            position = this._getPositionAfterNode(node, position);
        }));
        return position;
    }
    /**
     * @private
     * @param {?} node
     * @param {?} startPos
     * @return {?}
     */
    _getPositionAfterNode(node, startPos) {
        /** @type {?} */
        let position = node.getSelfHeight() + startPos;
        if (node.children && node.isExpanded) { // TBD: consider loading component as well
            position = this._getPositionAfter(node.visibleChildren, position);
        }
        node.height = position - startPos;
        return position;
    }
    /**
     * @return {?}
     */
    clear() {
        this._dispose.forEach((/**
         * @param {?} d
         * @return {?}
         */
        (d) => d()));
    }
    /**
     * @param {?} viewport
     * @return {?}
     */
    setViewport(viewport) {
        Object.assign(this, {
            viewport,
            x: viewport.scrollLeft,
            yBlocks: Math.round(viewport.scrollTop / Y_EPSILON),
            viewportHeight: viewport.getBoundingClientRect ? viewport.getBoundingClientRect().height : 0
        });
    }
    /**
     * @param {?} node
     * @param {?} force
     * @param {?=} scrollToMiddle
     * @return {?}
     */
    scrollIntoView(node, force, scrollToMiddle = true) {
        if (node.options.scrollContainer) {
            /** @type {?} */
            const scrollContainer = node.options.scrollContainer;
            /** @type {?} */
            const scrollContainerHeight = scrollContainer.getBoundingClientRect().height;
            /** @type {?} */
            const scrollContainerTop = scrollContainer.getBoundingClientRect().top;
            /** @type {?} */
            const nodeTop = this.viewport.getBoundingClientRect().top + node.position - scrollContainerTop;
            if (force || // force scroll to node
                nodeTop < scrollContainer.scrollTop || // node is above scroll container
                nodeTop + node.getSelfHeight() > scrollContainer.scrollTop + scrollContainerHeight) { // node is below container
                scrollContainer.scrollTop = scrollToMiddle ?
                    nodeTop - scrollContainerHeight / 2 : // scroll to middle
                    nodeTop; // scroll to start
            }
        }
        else {
            if (force || // force scroll to node
                node.position < this.y || // node is above viewport
                node.position + node.getSelfHeight() > this.y + this.viewportHeight) { // node is below viewport
                if (this.viewport) {
                    this.viewport.scrollTop = scrollToMiddle ?
                        node.position - this.viewportHeight / 2 : // scroll to middle
                        node.position; // scroll to start
                    this._setYBlocks(Math.floor(this.viewport.scrollTop / Y_EPSILON));
                }
            }
        }
    }
    /**
     * @param {?} nodes
     * @return {?}
     */
    getViewportNodes(nodes) {
        if (!nodes)
            return [];
        /** @type {?} */
        const visibleNodes = nodes.filter((/**
         * @param {?} node
         * @return {?}
         */
        (node) => !node.isHidden));
        if (!this.isEnabled())
            return visibleNodes;
        if (!this.viewportHeight || !visibleNodes.length)
            return [];
        // When loading children async this method is called before their height and position is calculated.
        // In that case firstIndex === 0 and lastIndex === visibleNodes.length - 1 (e.g. 1000),
        // which means that it loops through every visibleNodes item and push them into viewportNodes array.
        // We can prevent nodes from being pushed to the array and wait for the appropriate calculations to take place
        /** @type {?} */
        const lastVisibleNode = visibleNodes.slice(-1)[0];
        if (!lastVisibleNode.height && lastVisibleNode.position === 0)
            return [];
        // Search for first node in the viewport using binary search
        // Look for first node that starts after the beginning of the viewport (with buffer)
        // Or that ends after the beginning of the viewport
        /** @type {?} */
        const firstIndex = binarySearch(visibleNodes, (/**
         * @param {?} node
         * @return {?}
         */
        (node) => {
            return (node.position + Y_OFFSET > this.y) ||
                (node.position + node.height > this.y);
        }));
        // Search for last node in the viewport using binary search
        // Look for first node that starts after the end of the viewport (with buffer)
        /** @type {?} */
        const lastIndex = binarySearch(visibleNodes, (/**
         * @param {?} node
         * @return {?}
         */
        (node) => {
            return node.position - Y_OFFSET > this.y + this.viewportHeight;
        }), firstIndex);
        /** @type {?} */
        const viewportNodes = [];
        for (let i = firstIndex; i <= lastIndex; i++) {
            viewportNodes.push(visibleNodes[i]);
        }
        return viewportNodes;
    }
    /**
     * @return {?}
     */
    fixScroll() {
        /** @type {?} */
        const maxY = Math.max(0, this.totalHeight - this.viewportHeight);
        if (this.y < 0)
            this._setYBlocks(0);
        if (this.y > maxY)
            this._setYBlocks(maxY / Y_EPSILON);
    }
}
TreeVirtualScroll.decorators = [
    { type: Injectable }
];
/** @nocollapse */
TreeVirtualScroll.ctorParameters = () => [
    { type: TreeModel }
];
__decorate$2([
    observable$1,
    __metadata$2("design:type", Object)
], TreeVirtualScroll.prototype, "yBlocks", void 0);
__decorate$2([
    observable$1,
    __metadata$2("design:type", Object)
], TreeVirtualScroll.prototype, "x", void 0);
__decorate$2([
    observable$1,
    __metadata$2("design:type", Object)
], TreeVirtualScroll.prototype, "viewportHeight", void 0);
__decorate$2([
    computed$1,
    __metadata$2("design:type", Object),
    __metadata$2("design:paramtypes", [])
], TreeVirtualScroll.prototype, "y", null);
__decorate$2([
    computed$1,
    __metadata$2("design:type", Object),
    __metadata$2("design:paramtypes", [])
], TreeVirtualScroll.prototype, "totalHeight", null);
__decorate$2([
    action$1,
    __metadata$2("design:type", Function),
    __metadata$2("design:paramtypes", [Object]),
    __metadata$2("design:returntype", void 0)
], TreeVirtualScroll.prototype, "_setYBlocks", null);
__decorate$2([
    action$1,
    __metadata$2("design:type", Function),
    __metadata$2("design:paramtypes", []),
    __metadata$2("design:returntype", void 0)
], TreeVirtualScroll.prototype, "recalcPositions", null);
__decorate$2([
    action$1,
    __metadata$2("design:type", Function),
    __metadata$2("design:paramtypes", [Object]),
    __metadata$2("design:returntype", void 0)
], TreeVirtualScroll.prototype, "setViewport", null);
__decorate$2([
    action$1,
    __metadata$2("design:type", Function),
    __metadata$2("design:paramtypes", [Object, Object, Object]),
    __metadata$2("design:returntype", void 0)
], TreeVirtualScroll.prototype, "scrollIntoView", null);
if (false) {
    /**
     * @type {?}
     * @private
     */
    TreeVirtualScroll.prototype._dispose;
    /** @type {?} */
    TreeVirtualScroll.prototype.yBlocks;
    /** @type {?} */
    TreeVirtualScroll.prototype.x;
    /** @type {?} */
    TreeVirtualScroll.prototype.viewportHeight;
    /** @type {?} */
    TreeVirtualScroll.prototype.viewport;
    /**
     * @type {?}
     * @private
     */
    TreeVirtualScroll.prototype.treeModel;
}
/**
 * @param {?} nodes
 * @param {?} condition
 * @param {?=} firstIndex
 * @return {?}
 */
function binarySearch(nodes, condition, firstIndex = 0) {
    /** @type {?} */
    let index = firstIndex;
    /** @type {?} */
    let toIndex = nodes.length - 1;
    while (index !== toIndex) {
        /** @type {?} */
        let midIndex = Math.floor((index + toIndex) / 2);
        if (condition(nodes[midIndex])) {
            toIndex = midIndex;
        }
        else {
            if (index === midIndex)
                index = toIndex;
            else
                index = midIndex;
        }
    }
    return index;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/loading.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LoadingComponent {
}
LoadingComponent.decorators = [
    { type: Component, args: [{
                encapsulation: ViewEncapsulation.None,
                selector: 'tree-loading-component',
                template: `
    <span *ngIf="!template">loading...</span>
    <ng-container
      [ngTemplateOutlet]="template"
      [ngTemplateOutletContext]="{ $implicit: node }">
    </ng-container>
  `
            }] }
];
LoadingComponent.propDecorators = {
    template: [{ type: Input }],
    node: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    LoadingComponent.prototype.template;
    /** @type {?} */
    LoadingComponent.prototype.node;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/tree-viewport.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TreeViewportComponent {
    /**
     * @param {?} elementRef
     * @param {?} ngZone
     * @param {?} virtualScroll
     */
    constructor(elementRef, ngZone, virtualScroll) {
        this.elementRef = elementRef;
        this.ngZone = ngZone;
        this.virtualScroll = virtualScroll;
        this.setViewport = throttle((/**
         * @return {?}
         */
        () => {
            this.virtualScroll.setViewport(this.elementRef.nativeElement);
        }), 17);
        this.scrollEventHandler = this.setViewport.bind(this);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.virtualScroll.init();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        setTimeout((/**
         * @return {?}
         */
        () => {
            this.setViewport();
            this.virtualScroll.fireEvent({ eventName: TREE_EVENTS.initialized });
        }));
        /** @type {?} */
        let el = this.elementRef.nativeElement;
        this.ngZone.runOutsideAngular((/**
         * @return {?}
         */
        () => {
            el.addEventListener('scroll', this.scrollEventHandler);
        }));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.virtualScroll.clear();
        /** @type {?} */
        let el = this.elementRef.nativeElement;
        el.removeEventListener('scroll', this.scrollEventHandler);
    }
    /**
     * @return {?}
     */
    getTotalHeight() {
        return ((this.virtualScroll.isEnabled() &&
            this.virtualScroll.totalHeight + 'px') ||
            'auto');
    }
}
TreeViewportComponent.decorators = [
    { type: Component, args: [{
                selector: 'tree-viewport',
                providers: [TreeVirtualScroll],
                template: `
    <ng-container *treeMobxAutorun="{ dontDetach: true }">
      <div [style.height]="getTotalHeight()">
        <ng-content></ng-content>
      </div>
    </ng-container>
  `
            }] }
];
/** @nocollapse */
TreeViewportComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone },
    { type: TreeVirtualScroll }
];
if (false) {
    /** @type {?} */
    TreeViewportComponent.prototype.setViewport;
    /**
     * @type {?}
     * @private
     */
    TreeViewportComponent.prototype.scrollEventHandler;
    /**
     * @type {?}
     * @private
     */
    TreeViewportComponent.prototype.elementRef;
    /**
     * @type {?}
     * @private
     */
    TreeViewportComponent.prototype.ngZone;
    /** @type {?} */
    TreeViewportComponent.prototype.virtualScroll;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/tree.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TreeComponent {
    /**
     * @param {?} treeModel
     * @param {?} treeDraggedElement
     */
    constructor(treeModel, treeDraggedElement) {
        this.treeModel = treeModel;
        this.treeDraggedElement = treeDraggedElement;
        treeModel.eventNames.forEach((/**
         * @param {?} name
         * @return {?}
         */
        (name) => this[name] = new EventEmitter()));
        treeModel.subscribeToState((/**
         * @param {?} state
         * @return {?}
         */
        (state) => this.stateChange.emit(state)));
    }
    // Will be handled in ngOnChanges
    /**
     * @param {?} nodes
     * @return {?}
     */
    set nodes(nodes) {
    }
    ;
    /**
     * @param {?} options
     * @return {?}
     */
    set options(options) {
    }
    ;
    /**
     * @param {?} value
     * @return {?}
     */
    set focused(value) {
        this.treeModel.setFocus(value);
    }
    /**
     * @param {?} state
     * @return {?}
     */
    set state(state) {
        this.treeModel.setState(state);
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onKeydown($event) {
        if (!this.treeModel.isFocused)
            return;
        if (includes(['input', 'textarea'], document.activeElement.tagName.toLowerCase()))
            return;
        /** @type {?} */
        const focusedNode = this.treeModel.getFocusedNode();
        this.treeModel.performKeyAction(focusedNode, $event);
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onMousedown($event) {
        /**
         * @param {?} startElement
         * @param {?} nodeName
         * @return {?}
         */
        function isOutsideClick(startElement, nodeName) {
            return !startElement ? true : startElement.localName === nodeName ? false : isOutsideClick(startElement.parentElement, nodeName);
        }
        if (isOutsideClick($event.target, 'tree-root')) {
            this.treeModel.setFocus(false);
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.options || changes.nodes) {
            this.treeModel.setData({
                options: changes.options && changes.options.currentValue,
                nodes: changes.nodes && changes.nodes.currentValue,
                events: pick(this, this.treeModel.eventNames)
            });
        }
    }
    /**
     * @return {?}
     */
    sizeChanged() {
        this.viewportComponent.setViewport();
    }
}
TreeComponent.decorators = [
    { type: Component, args: [{
                selector: 'Tree, tree-root',
                providers: [TreeModel],
                template: `
      <tree-viewport #viewport>
          <div
                  class="angular-tree-component"
                  [class.node-dragging]="treeDraggedElement.isDragging()"
                  [class.angular-tree-component-rtl]="treeModel.options.rtl">
              <tree-node-collection
                      *ngIf="treeModel.roots"
                      [nodes]="treeModel.roots"
                      [treeModel]="treeModel"
                      [templates]="{
            loadingTemplate: loadingTemplate,
            treeNodeTemplate: treeNodeTemplate,
            treeNodeWrapperTemplate: treeNodeWrapperTemplate,
            treeNodeFullTemplate: treeNodeFullTemplate
          }">
              </tree-node-collection>
              <tree-node-drop-slot
                      class="empty-tree-drop-slot"
                      *ngIf="treeModel.isEmptyTree()"
                      [dropIndex]="0"
                      [node]="treeModel.virtualRoot">
              </tree-node-drop-slot>
          </div>
      </tree-viewport>
  `
            }] }
];
/** @nocollapse */
TreeComponent.ctorParameters = () => [
    { type: TreeModel },
    { type: TreeDraggedElement }
];
TreeComponent.propDecorators = {
    loadingTemplate: [{ type: ContentChild, args: ['loadingTemplate', { static: false },] }],
    treeNodeTemplate: [{ type: ContentChild, args: ['treeNodeTemplate', { static: false },] }],
    treeNodeWrapperTemplate: [{ type: ContentChild, args: ['treeNodeWrapperTemplate', { static: false },] }],
    treeNodeFullTemplate: [{ type: ContentChild, args: ['treeNodeFullTemplate', { static: false },] }],
    viewportComponent: [{ type: ViewChild, args: ['viewport', { static: false },] }],
    nodes: [{ type: Input }],
    options: [{ type: Input }],
    focused: [{ type: Input }],
    state: [{ type: Input }],
    toggleExpanded: [{ type: Output }],
    activate: [{ type: Output }],
    deactivate: [{ type: Output }],
    nodeActivate: [{ type: Output }],
    nodeDeactivate: [{ type: Output }],
    select: [{ type: Output }],
    deselect: [{ type: Output }],
    focus: [{ type: Output }],
    blur: [{ type: Output }],
    updateData: [{ type: Output }],
    initialized: [{ type: Output }],
    moveNode: [{ type: Output }],
    copyNode: [{ type: Output }],
    loadNodeChildren: [{ type: Output }],
    changeFilter: [{ type: Output }],
    event: [{ type: Output }],
    stateChange: [{ type: Output }],
    onKeydown: [{ type: HostListener, args: ['body: keydown', ['$event'],] }],
    onMousedown: [{ type: HostListener, args: ['body: mousedown', ['$event'],] }]
};
if (false) {
    /** @type {?} */
    TreeComponent.prototype._nodes;
    /** @type {?} */
    TreeComponent.prototype._options;
    /** @type {?} */
    TreeComponent.prototype.loadingTemplate;
    /** @type {?} */
    TreeComponent.prototype.treeNodeTemplate;
    /** @type {?} */
    TreeComponent.prototype.treeNodeWrapperTemplate;
    /** @type {?} */
    TreeComponent.prototype.treeNodeFullTemplate;
    /** @type {?} */
    TreeComponent.prototype.viewportComponent;
    /** @type {?} */
    TreeComponent.prototype.toggleExpanded;
    /** @type {?} */
    TreeComponent.prototype.activate;
    /** @type {?} */
    TreeComponent.prototype.deactivate;
    /** @type {?} */
    TreeComponent.prototype.nodeActivate;
    /** @type {?} */
    TreeComponent.prototype.nodeDeactivate;
    /** @type {?} */
    TreeComponent.prototype.select;
    /** @type {?} */
    TreeComponent.prototype.deselect;
    /** @type {?} */
    TreeComponent.prototype.focus;
    /** @type {?} */
    TreeComponent.prototype.blur;
    /** @type {?} */
    TreeComponent.prototype.updateData;
    /** @type {?} */
    TreeComponent.prototype.initialized;
    /** @type {?} */
    TreeComponent.prototype.moveNode;
    /** @type {?} */
    TreeComponent.prototype.copyNode;
    /** @type {?} */
    TreeComponent.prototype.loadNodeChildren;
    /** @type {?} */
    TreeComponent.prototype.changeFilter;
    /** @type {?} */
    TreeComponent.prototype.event;
    /** @type {?} */
    TreeComponent.prototype.stateChange;
    /** @type {?} */
    TreeComponent.prototype.treeModel;
    /** @type {?} */
    TreeComponent.prototype.treeDraggedElement;
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/tree-node.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TreeNodeComponent {
}
TreeNodeComponent.decorators = [
    { type: Component, args: [{
                selector: 'TreeNode, tree-node',
                encapsulation: ViewEncapsulation.None,
                template: `
    <ng-container *treeMobxAutorun="{ dontDetach: true }">
      <div
        *ngIf="!templates.treeNodeFullTemplate"
        [class]="node.getClass()"
        [class.tree-node]="true"
        [class.tree-node-expanded]="node.isExpanded && node.hasChildren"
        [class.tree-node-collapsed]="node.isCollapsed && node.hasChildren"
        [class.tree-node-leaf]="node.isLeaf"
        [class.tree-node-active]="node.isActive"
        [class.tree-node-focused]="node.isFocused"
      >
        <tree-node-drop-slot
          *ngIf="index === 0"
          [dropIndex]="node.index"
          [node]="node.parent"
        ></tree-node-drop-slot>

        <tree-node-wrapper
          [node]="node"
          [index]="index"
          [templates]="templates"
        ></tree-node-wrapper>

        <tree-node-children
          [node]="node"
          [templates]="templates"
        ></tree-node-children>
        <tree-node-drop-slot
          [dropIndex]="node.index + 1"
          [node]="node.parent"
        ></tree-node-drop-slot>
      </div>
      <ng-container
        [ngTemplateOutlet]="templates.treeNodeFullTemplate"
        [ngTemplateOutletContext]="{
          $implicit: node,
          node: node,
          index: index,
          templates: templates
        }"
      >
      </ng-container>
    </ng-container>
  `
            }] }
];
TreeNodeComponent.propDecorators = {
    node: [{ type: Input }],
    index: [{ type: Input }],
    templates: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    TreeNodeComponent.prototype.node;
    /** @type {?} */
    TreeNodeComponent.prototype.index;
    /** @type {?} */
    TreeNodeComponent.prototype.templates;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/tree-node-content.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TreeNodeContent {
}
TreeNodeContent.decorators = [
    { type: Component, args: [{
                selector: 'tree-node-content',
                encapsulation: ViewEncapsulation.None,
                template: `
  <span *ngIf="!template">{{ node.displayField }}</span>
  <ng-container
    [ngTemplateOutlet]="template"
    [ngTemplateOutletContext]="{ $implicit: node, node: node, index: index }">
  </ng-container>`
            }] }
];
TreeNodeContent.propDecorators = {
    node: [{ type: Input }],
    index: [{ type: Input }],
    template: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    TreeNodeContent.prototype.node;
    /** @type {?} */
    TreeNodeContent.prototype.index;
    /** @type {?} */
    TreeNodeContent.prototype.template;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/tree-node-drop-slot.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TreeNodeDropSlot {
    /**
     * @param {?} $event
     * @return {?}
     */
    onDrop($event) {
        this.node.mouseAction('drop', $event.event, {
            from: $event.element,
            to: { parent: this.node, index: this.dropIndex }
        });
    }
    /**
     * @param {?} element
     * @param {?} $event
     * @return {?}
     */
    allowDrop(element, $event) {
        return this.node.options.allowDrop(element, { parent: this.node, index: this.dropIndex }, $event);
    }
}
TreeNodeDropSlot.decorators = [
    { type: Component, args: [{
                selector: 'TreeNodeDropSlot, tree-node-drop-slot',
                encapsulation: ViewEncapsulation.None,
                template: `
    <div
      class="node-drop-slot"
      (treeDrop)="onDrop($event)"
      [treeAllowDrop]="allowDrop.bind(this)"
      [allowDragoverStyling]="true">
    </div>
  `
            }] }
];
TreeNodeDropSlot.propDecorators = {
    node: [{ type: Input }],
    dropIndex: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    TreeNodeDropSlot.prototype.node;
    /** @type {?} */
    TreeNodeDropSlot.prototype.dropIndex;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/tree-node-expander.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TreeNodeExpanderComponent {
}
TreeNodeExpanderComponent.decorators = [
    { type: Component, args: [{
                selector: 'tree-node-expander',
                encapsulation: ViewEncapsulation.None,
                template: `
    <ng-container *treeMobxAutorun="{ dontDetach: true }">
      <span
        *ngIf="node.hasChildren"
        [class.toggle-children-wrapper-expanded]="node.isExpanded"
        [class.toggle-children-wrapper-collapsed]="node.isCollapsed"
        class="toggle-children-wrapper"
        (click)="node.mouseAction('expanderClick', $event)"
      >
        <span class="toggle-children"></span>
      </span>
      <span *ngIf="!node.hasChildren" class="toggle-children-placeholder">
      </span>
    </ng-container>
  `
            }] }
];
TreeNodeExpanderComponent.propDecorators = {
    node: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    TreeNodeExpanderComponent.prototype.node;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/tree-node-children.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TreeNodeChildrenComponent {
}
TreeNodeChildrenComponent.decorators = [
    { type: Component, args: [{
                selector: 'tree-node-children',
                encapsulation: ViewEncapsulation.None,
                template: `
    <ng-container *treeMobxAutorun="{ dontDetach: true }">
      <div
        [class.tree-children]="true"
        [class.tree-children-no-padding]="node.options.levelPadding"
        *treeAnimateOpen="
          node.isExpanded;
          speed: node.options.animateSpeed;
          acceleration: node.options.animateAcceleration;
          enabled: node.options.animateExpand
        "
      >
        <tree-node-collection
          *ngIf="node.children"
          [nodes]="node.children"
          [templates]="templates"
          [treeModel]="node.treeModel"
        >
        </tree-node-collection>
        <tree-loading-component
          [style.padding-left]="node.getNodePadding()"
          class="tree-node-loading"
          *ngIf="!node.children"
          [template]="templates.loadingTemplate"
          [node]="node"
        ></tree-loading-component>
      </div>
    </ng-container>
  `
            }] }
];
TreeNodeChildrenComponent.propDecorators = {
    node: [{ type: Input }],
    templates: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    TreeNodeChildrenComponent.prototype.node;
    /** @type {?} */
    TreeNodeChildrenComponent.prototype.templates;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/mobx-angular/mobx-proxy.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Re-export mobx operators to be able to use inside components with AOT:
/**
 * @param {...?} args
 * @return {?}
 */
function actionInternal(...args) {
    return ((/** @type {?} */ (action$1)))(...args);
}
/** @type {?} */
const action = (/** @type {?} */ (Object.assign(actionInternal, action$1)));
/**
 * @param {...?} args
 * @return {?}
 */
function computedInternal(...args) {
    return ((/** @type {?} */ (computed$1)))(...args);
}
/** @type {?} */
const computed = (/** @type {?} */ (Object.assign(computedInternal, computed$1)));
/**
 * @param {...?} args
 * @return {?}
 */
function observableInternal(...args) {
    return ((/** @type {?} */ (observable$1)))(...args);
}
/** @type {?} */
const observable = (/** @type {?} */ (Object.assign(observableInternal, observable$1)));

var __decorate$3 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$3 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
class TreeNodeCollectionComponent {
    constructor() {
        this._dispose = [];
    }
    /**
     * @return {?}
     */
    get nodes() {
        return this._nodes;
    }
    /**
     * @param {?} nodes
     * @return {?}
     */
    set nodes(nodes) {
        this.setNodes(nodes);
    }
    /**
     * @return {?}
     */
    get marginTop() {
        /** @type {?} */
        const firstNode = this.viewportNodes && this.viewportNodes.length && this.viewportNodes[0];
        /** @type {?} */
        const relativePosition = firstNode && firstNode.parent
            ? firstNode.position -
                firstNode.parent.position -
                firstNode.parent.getSelfHeight()
            : 0;
        return `${relativePosition}px`;
    }
    /**
     * @param {?} nodes
     * @return {?}
     */
    setNodes(nodes) {
        this._nodes = nodes;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.virtualScroll = this.treeModel.virtualScroll;
        this._dispose = [
            // return node indexes so we can compare structurally,
            reaction((/**
             * @return {?}
             */
            () => {
                return this.virtualScroll
                    .getViewportNodes(this.nodes)
                    .map((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => n.index));
            }), (/**
             * @param {?} nodeIndexes
             * @return {?}
             */
            nodeIndexes => {
                this.viewportNodes = nodeIndexes.map((/**
                 * @param {?} i
                 * @return {?}
                 */
                i => this.nodes[i]));
            }), (/** @type {?} */ ({ compareStructural: true, fireImmediately: true }))),
            reaction((/**
             * @return {?}
             */
            () => this.nodes), (/**
             * @param {?} nodes
             * @return {?}
             */
            nodes => {
                this.viewportNodes = this.virtualScroll.getViewportNodes(nodes);
            }))
        ];
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._dispose.forEach((/**
         * @param {?} d
         * @return {?}
         */
        d => d()));
    }
    /**
     * @param {?} index
     * @param {?} node
     * @return {?}
     */
    trackNode(index, node) {
        return node.id;
    }
}
TreeNodeCollectionComponent.decorators = [
    { type: Component, args: [{
                selector: 'tree-node-collection',
                encapsulation: ViewEncapsulation.None,
                template: `
    <ng-container *treeMobxAutorun="{ dontDetach: true }">
      <div [style.margin-top]="marginTop">
        <tree-node
          *ngFor="let node of viewportNodes; let i = index; trackBy: trackNode"
          [node]="node"
          [index]="i"
          [templates]="templates"
        >
        </tree-node>
      </div>
    </ng-container>
  `
            }] }
];
TreeNodeCollectionComponent.propDecorators = {
    nodes: [{ type: Input }],
    treeModel: [{ type: Input }],
    templates: [{ type: Input }]
};
__decorate$3([
    observable,
    __metadata$3("design:type", Object)
], TreeNodeCollectionComponent.prototype, "_nodes", void 0);
__decorate$3([
    observable,
    __metadata$3("design:type", Array)
], TreeNodeCollectionComponent.prototype, "viewportNodes", void 0);
__decorate$3([
    computed,
    __metadata$3("design:type", String),
    __metadata$3("design:paramtypes", [])
], TreeNodeCollectionComponent.prototype, "marginTop", null);
__decorate$3([
    action,
    __metadata$3("design:type", Function),
    __metadata$3("design:paramtypes", [Object]),
    __metadata$3("design:returntype", void 0)
], TreeNodeCollectionComponent.prototype, "setNodes", null);
if (false) {
    /** @type {?} */
    TreeNodeCollectionComponent.prototype.treeModel;
    /** @type {?} */
    TreeNodeCollectionComponent.prototype._nodes;
    /**
     * @type {?}
     * @private
     */
    TreeNodeCollectionComponent.prototype.virtualScroll;
    /** @type {?} */
    TreeNodeCollectionComponent.prototype.templates;
    /** @type {?} */
    TreeNodeCollectionComponent.prototype.viewportNodes;
    /** @type {?} */
    TreeNodeCollectionComponent.prototype._dispose;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/tree-node-wrapper.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TreeNodeWrapperComponent {
    constructor() {
    }
}
TreeNodeWrapperComponent.decorators = [
    { type: Component, args: [{
                selector: 'tree-node-wrapper',
                encapsulation: ViewEncapsulation.None,
                template: `
      <div *ngIf="!templates.treeNodeWrapperTemplate" class="node-wrapper" [style.padding-left]="node.getNodePadding()">
          <tree-node-checkbox *ngIf="node.options.useCheckbox" [node]="node"></tree-node-checkbox>
          <tree-node-expander [node]="node"></tree-node-expander>
          <div class="node-content-wrapper"
               [class.node-content-wrapper-active]="node.isActive"
               [class.node-content-wrapper-focused]="node.isFocused"
               (click)="node.mouseAction('click', $event)"
               (dblclick)="node.mouseAction('dblClick', $event)"
               (mouseover)="node.mouseAction('mouseOver', $event)"
               (mouseout)="node.mouseAction('mouseOut', $event)"
               (contextmenu)="node.mouseAction('contextMenu', $event)"
               (treeDrop)="node.onDrop($event)"
               (treeDropDragOver)="node.mouseAction('dragOver', $event)"
               (treeDropDragLeave)="node.mouseAction('dragLeave', $event)"
               (treeDropDragEnter)="node.mouseAction('dragEnter', $event)"
               [treeAllowDrop]="node.allowDrop"
               [allowDragoverStyling]="node.allowDragoverStyling()"
               [treeDrag]="node"
               [treeDragEnabled]="node.allowDrag()">

              <tree-node-content [node]="node" [index]="index" [template]="templates.treeNodeTemplate">
              </tree-node-content>
          </div>
      </div>
      <ng-container
              [ngTemplateOutlet]="templates.treeNodeWrapperTemplate"
              [ngTemplateOutletContext]="{ $implicit: node, node: node, index: index, templates: templates }">
      </ng-container>
  `
            }] }
];
/** @nocollapse */
TreeNodeWrapperComponent.ctorParameters = () => [];
TreeNodeWrapperComponent.propDecorators = {
    node: [{ type: Input }],
    index: [{ type: Input }],
    templates: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    TreeNodeWrapperComponent.prototype.node;
    /** @type {?} */
    TreeNodeWrapperComponent.prototype.index;
    /** @type {?} */
    TreeNodeWrapperComponent.prototype.templates;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/tree-node-checkbox.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TreeNodeCheckboxComponent {
}
TreeNodeCheckboxComponent.decorators = [
    { type: Component, args: [{
                selector: 'tree-node-checkbox',
                encapsulation: ViewEncapsulation.None,
                template: `
    <ng-container *treeMobxAutorun="{ dontDetach: true }">
      <input
        class="tree-node-checkbox"
        type="checkbox"
        (click)="node.mouseAction('checkboxClick', $event)"
        [checked]="node.isSelected"
        [indeterminate]="node.isPartiallySelected"
      />
    </ng-container>
  `
            }] }
];
TreeNodeCheckboxComponent.propDecorators = {
    node: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    TreeNodeCheckboxComponent.prototype.node;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/tree-drop.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DRAG_OVER_CLASS = 'is-dragging-over';
/** @type {?} */
const DRAG_DISABLED_CLASS = 'is-dragging-over-disabled';
class TreeDropDirective {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} treeDraggedElement
     * @param {?} ngZone
     */
    constructor(el, renderer, treeDraggedElement, ngZone) {
        this.el = el;
        this.renderer = renderer;
        this.treeDraggedElement = treeDraggedElement;
        this.ngZone = ngZone;
        this.allowDragoverStyling = true;
        this.onDropCallback = new EventEmitter();
        this.onDragOverCallback = new EventEmitter();
        this.onDragLeaveCallback = new EventEmitter();
        this.onDragEnterCallback = new EventEmitter();
        this._allowDrop = (/**
         * @param {?} element
         * @param {?} $event
         * @return {?}
         */
        (element, $event) => true);
        this.dragOverEventHandler = this.onDragOver.bind(this);
        this.dragEnterEventHandler = this.onDragEnter.bind(this);
        this.dragLeaveEventHandler = this.onDragLeave.bind(this);
    }
    /**
     * @param {?} allowDrop
     * @return {?}
     */
    set treeAllowDrop(allowDrop) {
        if (allowDrop instanceof Function) {
            this._allowDrop = allowDrop;
        }
        else
            this._allowDrop = (/**
             * @param {?} element
             * @param {?} $event
             * @return {?}
             */
            (element, $event) => allowDrop);
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    allowDrop($event) {
        return this._allowDrop(this.treeDraggedElement.get(), $event);
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        /** @type {?} */
        let el = this.el.nativeElement;
        this.ngZone.runOutsideAngular((/**
         * @return {?}
         */
        () => {
            el.addEventListener('dragover', this.dragOverEventHandler);
            el.addEventListener('dragenter', this.dragEnterEventHandler);
            el.addEventListener('dragleave', this.dragLeaveEventHandler);
        }));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        /** @type {?} */
        let el = this.el.nativeElement;
        el.removeEventListener('dragover', this.dragOverEventHandler);
        el.removeEventListener('dragenter', this.dragEnterEventHandler);
        el.removeEventListener('dragleave', this.dragLeaveEventHandler);
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onDragOver($event) {
        if (!this.allowDrop($event)) {
            if (this.allowDragoverStyling) {
                return this.addDisabledClass();
            }
            return;
        }
        this.onDragOverCallback.emit({ event: $event, element: this.treeDraggedElement.get() });
        $event.preventDefault();
        if (this.allowDragoverStyling) {
            this.addClass();
        }
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onDragEnter($event) {
        if (!this.allowDrop($event))
            return;
        $event.preventDefault();
        this.onDragEnterCallback.emit({ event: $event, element: this.treeDraggedElement.get() });
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onDragLeave($event) {
        if (!this.allowDrop($event)) {
            if (this.allowDragoverStyling) {
                return this.removeDisabledClass();
            }
            return;
        }
        this.onDragLeaveCallback.emit({ event: $event, element: this.treeDraggedElement.get() });
        if (this.allowDragoverStyling) {
            this.removeClass();
        }
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onDrop($event) {
        if (!this.allowDrop($event))
            return;
        $event.preventDefault();
        this.onDropCallback.emit({ event: $event, element: this.treeDraggedElement.get() });
        if (this.allowDragoverStyling) {
            this.removeClass();
        }
        this.treeDraggedElement.set(null);
    }
    /**
     * @private
     * @return {?}
     */
    addClass() {
        this.renderer.addClass(this.el.nativeElement, DRAG_OVER_CLASS);
    }
    /**
     * @private
     * @return {?}
     */
    removeClass() {
        this.renderer.removeClass(this.el.nativeElement, DRAG_OVER_CLASS);
    }
    /**
     * @private
     * @return {?}
     */
    addDisabledClass() {
        this.renderer.addClass(this.el.nativeElement, DRAG_DISABLED_CLASS);
    }
    /**
     * @private
     * @return {?}
     */
    removeDisabledClass() {
        this.renderer.removeClass(this.el.nativeElement, DRAG_DISABLED_CLASS);
    }
}
TreeDropDirective.decorators = [
    { type: Directive, args: [{
                selector: '[treeDrop]'
            },] }
];
/** @nocollapse */
TreeDropDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: TreeDraggedElement },
    { type: NgZone }
];
TreeDropDirective.propDecorators = {
    allowDragoverStyling: [{ type: Input }],
    onDropCallback: [{ type: Output, args: ['treeDrop',] }],
    onDragOverCallback: [{ type: Output, args: ['treeDropDragOver',] }],
    onDragLeaveCallback: [{ type: Output, args: ['treeDropDragLeave',] }],
    onDragEnterCallback: [{ type: Output, args: ['treeDropDragEnter',] }],
    treeAllowDrop: [{ type: Input }],
    onDrop: [{ type: HostListener, args: ['drop', ['$event'],] }]
};
if (false) {
    /** @type {?} */
    TreeDropDirective.prototype.allowDragoverStyling;
    /** @type {?} */
    TreeDropDirective.prototype.onDropCallback;
    /** @type {?} */
    TreeDropDirective.prototype.onDragOverCallback;
    /** @type {?} */
    TreeDropDirective.prototype.onDragLeaveCallback;
    /** @type {?} */
    TreeDropDirective.prototype.onDragEnterCallback;
    /**
     * @type {?}
     * @private
     */
    TreeDropDirective.prototype.dragOverEventHandler;
    /**
     * @type {?}
     * @private
     */
    TreeDropDirective.prototype.dragEnterEventHandler;
    /**
     * @type {?}
     * @private
     */
    TreeDropDirective.prototype.dragLeaveEventHandler;
    /**
     * @type {?}
     * @private
     */
    TreeDropDirective.prototype._allowDrop;
    /**
     * @type {?}
     * @private
     */
    TreeDropDirective.prototype.el;
    /**
     * @type {?}
     * @private
     */
    TreeDropDirective.prototype.renderer;
    /**
     * @type {?}
     * @private
     */
    TreeDropDirective.prototype.treeDraggedElement;
    /**
     * @type {?}
     * @private
     */
    TreeDropDirective.prototype.ngZone;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/tree-drag.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DRAG_OVER_CLASS$1 = 'is-dragging-over';
class TreeDragDirective {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} treeDraggedElement
     * @param {?} ngZone
     */
    constructor(el, renderer, treeDraggedElement, ngZone) {
        this.el = el;
        this.renderer = renderer;
        this.treeDraggedElement = treeDraggedElement;
        this.ngZone = ngZone;
        this.dragEventHandler = this.onDrag.bind(this);
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        /** @type {?} */
        let el = this.el.nativeElement;
        this.ngZone.runOutsideAngular((/**
         * @return {?}
         */
        () => {
            el.addEventListener('drag', this.dragEventHandler);
        }));
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        this.renderer.setAttribute(this.el.nativeElement, 'draggable', this.treeDragEnabled ? 'true' : 'false');
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        /** @type {?} */
        let el = this.el.nativeElement;
        el.removeEventListener('drag', this.dragEventHandler);
    }
    /**
     * @param {?} ev
     * @return {?}
     */
    onDragStart(ev) {
        // setting the data is required by firefox
        ev.dataTransfer.setData('text', ev.target.id);
        this.treeDraggedElement.set(this.draggedElement);
        if (this.draggedElement.mouseAction) {
            this.draggedElement.mouseAction('dragStart', ev);
        }
    }
    /**
     * @param {?} ev
     * @return {?}
     */
    onDrag(ev) {
        if (this.draggedElement.mouseAction) {
            this.draggedElement.mouseAction('drag', ev);
        }
    }
    /**
     * @return {?}
     */
    onDragEnd() {
        if (this.draggedElement.mouseAction) {
            this.draggedElement.mouseAction('dragEnd');
        }
        this.treeDraggedElement.set(null);
    }
}
TreeDragDirective.decorators = [
    { type: Directive, args: [{
                selector: '[treeDrag]'
            },] }
];
/** @nocollapse */
TreeDragDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: TreeDraggedElement },
    { type: NgZone }
];
TreeDragDirective.propDecorators = {
    draggedElement: [{ type: Input, args: ['treeDrag',] }],
    treeDragEnabled: [{ type: Input }],
    onDragStart: [{ type: HostListener, args: ['dragstart', ['$event'],] }],
    onDragEnd: [{ type: HostListener, args: ['dragend',] }]
};
if (false) {
    /** @type {?} */
    TreeDragDirective.prototype.draggedElement;
    /** @type {?} */
    TreeDragDirective.prototype.treeDragEnabled;
    /**
     * @type {?}
     * @private
     */
    TreeDragDirective.prototype.dragEventHandler;
    /**
     * @type {?}
     * @private
     */
    TreeDragDirective.prototype.el;
    /**
     * @type {?}
     * @private
     */
    TreeDragDirective.prototype.renderer;
    /**
     * @type {?}
     * @private
     */
    TreeDragDirective.prototype.treeDraggedElement;
    /**
     * @type {?}
     * @private
     */
    TreeDragDirective.prototype.ngZone;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/tree-animate-open.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const EASE_ACCELERATION = 1.005;
class TreeAnimateOpenDirective {
    /**
     * @param {?} renderer
     * @param {?} templateRef
     * @param {?} viewContainerRef
     */
    constructor(renderer, templateRef, viewContainerRef) {
        this.renderer = renderer;
        this.templateRef = templateRef;
        this.viewContainerRef = viewContainerRef;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set isOpen(value) {
        if (value) {
            this._show();
            if (this.isEnabled && this._isOpen === false) {
                this._animateOpen();
            }
        }
        else {
            this.isEnabled ? this._animateClose() : this._hide();
        }
        this._isOpen = !!value;
    }
    ;
    /**
     * @private
     * @return {?}
     */
    _show() {
        if (this.innerElement)
            return;
        // create child view
        this.innerElement = this.viewContainerRef.createEmbeddedView(this.templateRef).rootNodes[0];
    }
    /**
     * @private
     * @return {?}
     */
    _hide() {
        this.viewContainerRef.clear();
        this.innerElement = null;
    }
    /**
     * @private
     * @return {?}
     */
    _animateOpen() {
        /** @type {?} */
        let delta = this.animateSpeed;
        /** @type {?} */
        let ease = this.animateAcceleration;
        /** @type {?} */
        let maxHeight = 0;
        // set height to 0
        this.renderer.setStyle(this.innerElement, 'max-height', `0`);
        // increase maxHeight until height doesn't change
        setTimeout((/**
         * @return {?}
         */
        () => {
            // Allow inner element to create its content
            /** @type {?} */
            const i = setInterval((/**
             * @return {?}
             */
            () => {
                if (!this._isOpen || !this.innerElement)
                    return clearInterval(i);
                maxHeight += delta;
                /** @type {?} */
                const roundedMaxHeight = Math.round(maxHeight);
                this.renderer.setStyle(this.innerElement, 'max-height', `${roundedMaxHeight}px`);
                /** @type {?} */
                const height = this.innerElement.getBoundingClientRect ? this.innerElement.getBoundingClientRect().height : 0;
                delta *= ease;
                ease *= EASE_ACCELERATION;
                if (height < roundedMaxHeight) {
                    // Make maxHeight auto because animation finished and container might change height later on
                    this.renderer.setStyle(this.innerElement, 'max-height', null);
                    clearInterval(i);
                }
            }), 17);
        }));
    }
    /**
     * @private
     * @return {?}
     */
    _animateClose() {
        if (!this.innerElement)
            return;
        /** @type {?} */
        let delta = this.animateSpeed;
        /** @type {?} */
        let ease = this.animateAcceleration;
        /** @type {?} */
        let height = this.innerElement.getBoundingClientRect().height;
        // TBD use renderer
        // slowly decrease maxHeight to 0, starting from current height
        /** @type {?} */
        const i = setInterval((/**
         * @return {?}
         */
        () => {
            if (this._isOpen || !this.innerElement)
                return clearInterval(i);
            height -= delta;
            this.renderer.setStyle(this.innerElement, 'max-height', `${height}px`);
            delta *= ease;
            ease *= EASE_ACCELERATION;
            if (height <= 0) {
                // after animation complete - remove child element
                this.viewContainerRef.clear();
                this.innerElement = null;
                clearInterval(i);
            }
        }), 17);
    }
}
TreeAnimateOpenDirective.decorators = [
    { type: Directive, args: [{
                selector: '[treeAnimateOpen]'
            },] }
];
/** @nocollapse */
TreeAnimateOpenDirective.ctorParameters = () => [
    { type: Renderer2 },
    { type: TemplateRef },
    { type: ViewContainerRef }
];
TreeAnimateOpenDirective.propDecorators = {
    animateSpeed: [{ type: Input, args: ['treeAnimateOpenSpeed',] }],
    animateAcceleration: [{ type: Input, args: ['treeAnimateOpenAcceleration',] }],
    isEnabled: [{ type: Input, args: ['treeAnimateOpenEnabled',] }],
    isOpen: [{ type: Input, args: ['treeAnimateOpen',] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    TreeAnimateOpenDirective.prototype._isOpen;
    /** @type {?} */
    TreeAnimateOpenDirective.prototype.animateSpeed;
    /** @type {?} */
    TreeAnimateOpenDirective.prototype.animateAcceleration;
    /** @type {?} */
    TreeAnimateOpenDirective.prototype.isEnabled;
    /**
     * @type {?}
     * @private
     */
    TreeAnimateOpenDirective.prototype.innerElement;
    /**
     * @type {?}
     * @private
     */
    TreeAnimateOpenDirective.prototype.renderer;
    /**
     * @type {?}
     * @private
     */
    TreeAnimateOpenDirective.prototype.templateRef;
    /**
     * @type {?}
     * @private
     */
    TreeAnimateOpenDirective.prototype.viewContainerRef;
    /* Skipping unhandled member: ;*/
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/angular-tree-component.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TreeModule {
}
TreeModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    TreeComponent,
                    TreeNodeComponent,
                    TreeNodeContent,
                    LoadingComponent,
                    TreeDropDirective,
                    TreeDragDirective,
                    TreeNodeExpanderComponent,
                    TreeNodeChildrenComponent,
                    TreeNodeDropSlot,
                    TreeNodeCollectionComponent,
                    TreeViewportComponent,
                    TreeNodeWrapperComponent,
                    TreeNodeCheckboxComponent,
                    TreeAnimateOpenDirective,
                    TreeMobxAutorunDirective
                ],
                exports: [
                    TreeComponent,
                    TreeNodeComponent,
                    TreeNodeContent,
                    LoadingComponent,
                    TreeDropDirective,
                    TreeDragDirective,
                    TreeNodeExpanderComponent,
                    TreeNodeChildrenComponent,
                    TreeNodeDropSlot,
                    TreeNodeCollectionComponent,
                    TreeViewportComponent,
                    TreeNodeWrapperComponent,
                    TreeNodeCheckboxComponent,
                    TreeAnimateOpenDirective,
                    TreeMobxAutorunDirective
                ],
                imports: [CommonModule],
                providers: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: circlon-angular-tree-component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { KEYS, LoadingComponent, TREE_ACTIONS, TreeAnimateOpenDirective, TreeComponent, TreeDragDirective, TreeDraggedElement, TreeDropDirective, TreeModel, TreeModule, TreeNode, TreeNodeCheckboxComponent, TreeNodeChildrenComponent, TreeNodeCollectionComponent, TreeNodeComponent, TreeNodeContent, TreeNodeDropSlot, TreeNodeExpanderComponent, TreeNodeWrapperComponent, TreeViewportComponent, TreeVirtualScroll, actionInternal as ɵa, action as ɵb, computed as ɵc, observable as ɵd, TreeMobxAutorunDirective as ɵe };
//# sourceMappingURL=circlon-angular-tree-component.js.map
